<dom-module id="kazoup-analytics-data">
  <script>
    'use strict';

    (function() {
      /**
       * makes requests to elasticsearch based on dimension, post processes response, sets chartData & histogramData
       */
      Polymer({
        is: 'kazoup-analytics-data',
        behaviors: [
          KazoupBehaviors.NetworkError,
          KazoupBehaviors.APIUrls
        ],
        properties: {
          chartData: {
            type: Object,
            notify: true
          },
          histogramData: {
            type: Object,
            notify: true
          },
          dimension: {
            type: String,
            notify: true,
            observer: 'dimensionChanged'
          },
          secondDimension: {
            type: String,
            notify: true,
            observer: 'secondDimensionChanged'
          },
          visualisation: {
            type: String,
            notify: true,
            observer: 'visualisationChanged'
          },
          period: {
            type: String,
            notify: false
          },
          requestInProgress: {
            type: Boolean,
            notify: true,
            value: false
          },
          target: {
            type: String,
            notify: false
          },
          firstLoad: {
            type: Boolean,
            notify: false,
            value: true
          },
          bidimensionalSecondDimensionSizeAgg: {
            type: Number,
            notify: false,
            value: 10
          },
          bidimensionalSizeAgg: {
            type: Number,
            notify: false,
            value: 20
          },
          bVisualisationMap: {
            type: Array,
            notify: false,
            value: function() {
              return [
                'chord',
                'force_directed',
                'sankey',
                'matrix'
              ];
            }
          }
        },
        dimensionChanged: function(newVal, oldVal) {
          if (oldVal && newVal) {
            this.dataQueryParamsChanged();
          }
        },
        secondDimensionChanged: function(newVal, oldVal) {
          if (oldVal && newVal) {
            this.dataQueryParamsChanged();
          }
        },
        visualisationChanged: function(newVal, oldVal) {
          if (oldVal && newVal) {
            this.dataQueryParamsChanged();
          }
        },
        dataQueryParamsChanged: function() {
          var fetchData = false;

          // Fetch data when these four params are ready and set
          if (this.bVisualisationMap.indexOf(this.visualisation) !== -1) {
            // Bidimensional; secondDimension required
            if (!!this.dimension && !!this.secondDimension && this.secondDimension !== 'none') {
              fetchData = true;
            }
          } else {
            if (!!this.dimension) {
              fetchData = true;
            }
          }

          if (fetchData && (this.dimension && this.secondDimension &&
              this.visualisation && this.period &&
              this._filterConverter.getValue('from') && this._filterConverter.getValue('to'))) {
            this._fetchChartData();
          }
        },
        _handleFilterChanged: function(event) {
          var from = this._filterConverter.getValue('from');
          var to = this._filterConverter.getValue('to');
          var changedFields = _.pluck(event.detail.fieldsChanged, 'field');
          var dataFetched = false;

          if (from !== undefined && to !== undefined) {
            if (this.firstLoad && changedFields.length === 0 &&
              (this.dimension && this.period && this.visualisation)) {
              // Event was fired, whole filters object has been set
              // this happens when /analytics URL is hitted
              this.firstLoad = false;
              this._fetchChartData();
              this._fetchHistogramData();
            } else if (changedFields.length === 1 && changedFields[0] === 'timestampType') {
              // no point reloading chart as data will be the same
              this._fetchHistogramData();
            } else {
              // Due to multifilter selection, we won't refresh the chart data when user
              // sets a filter which belongs to the visualize dimension
              _.forEach(event.detail.fieldsChanged, function (filter) {
                if (filter.field !== this.dimension) {
                  if (filter.field !== 'unique' || this.dimension !== 'duplicates') {
                    this._fetchChartData();
                    dataFetched = true;
                    return false;
                  }
                }
              }, this);

              // Bidimensional visualisations have to be refresehed always, because all filters must be applied
              if (!dataFetched && (this.dimension === 'places_person' ||
                this.dimension === 'places_organisation' ||
                this.dimension === 'places_location') ||
                (this.bVisualisationMap.indexOf(this.visualisation) !== -1)) {
                this._fetchChartData();
              }

              // Histogram data has to be refreshed anyway
              // because filters changed
              if (changedFields.length !== 0) {
                this._fetchHistogramData();
              }
            }
          }
        },
        _fetchChartData: function() {
          var chartDataPromise;

          this.requestInProgress = true;
          var nestedAgg;
          var aggs;

          if (this.bVisualisationMap.indexOf(this.visualisation) !== -1) {
            if (this.secondDimension !== this.dimension && this.secondDimension !== 'none') {
              nestedAgg = this._methodsMap[this.secondDimension].buildAggs('nested_' + this.secondDimension + '_');
              _.filter(nestedAgg, function(nested) {
                if (nested.terms) {
                  nested.terms.size = this.bidimensionalSecondDimensionSizeAgg;
                }
              }, this);
            }
          }

          aggs = this._methodsMap[this.dimension].buildAggs('', nestedAgg);
          chartDataPromise = this._makeChartRequest(aggs);

          return chartDataPromise.catch(this.handleNetworkError);
        },
        _fetchHistogramData: function() {
          return this._makeHistogramRequest().catch(this.handleNetworkError);
        },
        _fetchAllData: function() {
          this._fetchChartData();
          this._fetchHistogramData();
        },
        _makeHistogramRequest: function() {
          var query = {
            'query':{
              'constant_score':{
                'filter': {
                  'match_all': {}
                }
              }
            },
            'facets':{
              'histogram':{
                'date_histogram':{
                  'value_field':'metadata.size',
                  'interval': this.period,
                  'key_field': this._filterConverter.getValue('timestampType')
                },
                'facet_filter':{
                  'and':[
                    {
                      'bool':{
                        'should':[
                          {
                            'term':{
                              'exists_on_disk':true
                            }
                          },
                          {
                            'exists':{
                              'field':'archive_complete'
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            },
            'size':0
          };

          query.facets.histogram.facet_filter.and.push(this._filterConverter.asElasticsearchFilters());

          var _self = this;

          return qwest.post(
            this.endpointList.ESFiles,
            {
              index: "files",
              type: "file",
              query: query
            },
            {
              dataType: 'json',
              cache: true,
              headers: {
                Accept: 'application/json',
                Authorization: 'JWT ' + localStorage.getItem('authToken')
              }
            }
          )
            .then(function(xhr, response) {
              if (response.facets.histogram.entries.length) {
                // pad dates
                var first = new Date(_.first(response.facets.histogram.entries).time);
                var last = new Date(_.last(response.facets.histogram.entries).time);
                var current = new Date(first.getTime());
                var padding = [];

                if (_self.period === 'year') {
                  _.times(Math.floor(first.getMonthsBetween(last) / 12), function () {
                    current = current.add({years: 1});
                    padding.push({
                      time: current.getTime(),
                      count: 0,
                      total: 0,
                      size_human: 0,
                      size_human_measure: 'B'
                    });
                  });
                } else if (_self.period === 'month') {
                  _.times(first.getMonthsBetween(last), function () {
                    current = current.add({months: 1});
                    padding.push({
                      time: current.getTime(),
                      count: 0,
                      total: 0,
                      size_human: 0,
                      size_human_measure: 'B'
                    });
                  });
                } else if (_self.period === 'day') {
                  _.times(first.getDaysBetween(last), function () {
                    current = current.add({days: 1});
                    padding.push({
                      time: current.getTime(),
                      count: 0,
                      total: 0,
                      size_human: 0,
                      size_human_measure: 'B'
                    });
                  });
                }

                var results = [];
                _.forEach(response.facets.histogram.entries, function (item) {
                  var size = filesize(item.total, {output: 'array'});
                  results.push({
                    time: item.time,
                    count: item.count,
                    total: item.total,
                    size_human: size[0],
                    size_human_measure: size[1]
                  });
                });

                // merge in the padding, then ensure uniquness taking only the first object
                // for each 'time', thus removing
                // removing padding objects where a real value exists
                _self.histogramData = _.chain(results.concat(padding))
                  .sortBy('time')
                  .uniq(true,
                  function (item) {
                    var dateToNormalize = new Date(item.time);

                    // JS (v8 chorme at least) is generating BST dates for timestamps if those
                    // timestamps falls into summer period, if not, GMT is generated.
                    // This issue force a padding for summer months.
                    // To fix it, return a string concatenating year and month, so if value generated is equal
                    // padding is force to pop out
                    return dateToNormalize.getUTCFullYear().toString() +
                      dateToNormalize.getUTCMonth().toString() +
                      dateToNormalize.getDate().toString();
                  })
                  .value();
              } else {
                _self.histogramData = [];
              }

              _self.requestInProgress = false;

              return _self.histogramData;
            });

        },
        _makeChartRequest: function(aggs) {
          var data = [];
          var query = {
            'query': this._getESBasicQuery(),
            'aggs': aggs,
            'size': 0
          };

          // Multiple filter selection on unidimensional charts
          // We want to apply all filters in ALL the following cases:
          // 1. Multidimensional visualisation
          // 2. Visualise location
          // 3. Visualise dimensions which data comes from file content extraction
          if (this.secondDimension === 'none') {
            if (this.dimension === 'duplicates') {
              query.query.constant_score.filter.bool.must.push(
                this._filterConverter.asElasticsearchFilters('unique')
              );
            } else if (this.dimension === 'location' ||
                this.dimension === 'places_person' ||
                this.dimension === 'places_organisation' ||
                this.dimension === 'places_location') {
              query.query.constant_score.filter.bool.must.push(
                this._filterConverter.asElasticsearchFilters()
              );
            } else {
              query.query.constant_score.filter.bool.must.push(
                this._filterConverter.asElasticsearchFilters(this.dimension)
              );
            }
          } else {
            query.query.constant_score.filter.bool.must.push(
              this._filterConverter.asElasticsearchFilters()
            );
          }

          var _self = this;

          return qwest.post(
            this.endpointList.ESFiles,
            {
              index: "files",
              type: "file",
              query: query
            },
            {
              dataType: 'json',
              cache: true,
              headers: {
                Accept: 'application/json',
                Authorization: 'JWT ' + localStorage.getItem('authToken')
              }
            }
          ).then(function(xhr, response) {
            _self.set('chartData', []);
            data = _self._methodsMap[_self.dimension].postProcess(response.aggregations);

            if (_self.dimension === _self.secondDimension) {
              data = _self._buildSingleDimensionMatrix(data);
            } else if (_self.secondDimension &&
              _self.secondDimension !== 'none' &&
              _self.dimension !== _self.secondDimension) {
              data = _self._buildTwoDimensionMatrix(data);
            }

            _self.set('chartData', data);

            return _self.chartData;
          });
        },
        _setObjectPercentage: function(array) {
          array = _.chain(array);
          var sum = array.sum('total').value();
          return array.each(function(item) {
            if (item.total > 0) {
              item.percent = item.total / sum;
            } else {
              item.percent = 0;
            }
          }).value();
        },
        _getESBasicQuery: function() {
          return {
            'constant_score':{
              'filter':{
                'bool':{
                  'must':[
                    {
                      'bool':{
                        'should':[
                          {
                            'term':{
                              'exists_on_disk':true
                            }
                          },
                          {
                            'exists':{
                              'field':'archive_complete'
                            }
                          }
                        ],
                        'must':[
                        ]
                      }
                    }
                  ]
                }
              }
            }
          };
        },
        _getLocationAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var dirpath = this._filterConverter.getValue('dirpath');
          var level = 1;
          if (dirpath.length) {
            // mustn't be lower than 1
            level = _.max([dirpath[0].substring(2).split('/').length, 1]);
            dirpath += '/';  // needed to match value in elasticsearch
          } else {
            dirpath = '';
          }

          var agg = {};
          agg[aggPrefix + 'files_in_dir'] = {
            'filter': {
              'term': {
                'dirpath': dirpath
              }
            },
            'aggs': {
              'total_size': {
                'stats': {
                  'field': 'metadata.size'
                }
              }
            }
          };
          agg[aggPrefix + 'buckets'] = {
            'terms': {
              'field': 'metadata.dirpath_split.' + level,
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'stats': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            _.forEach(nestedAgg, function(v, k) {
              agg[aggPrefix + 'files_in_dir'].aggs[k] = v;
              agg[aggPrefix + 'buckets'].aggs[k] = v;
            });
          }

          return agg;
        },
        _getDocTypeAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};
          agg[aggPrefix + 'totals'] = {
            'terms':{
              'field':'metadata.doc_type',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'stats': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            _.forEach(nestedAgg, function(v, k) {
              agg[aggPrefix + 'totals'].aggs[k] = v;
            });
          }

          return agg;
        },
        _getExtensionAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};
          agg[aggPrefix + 'totals'] = {
            'terms':{
              'field':'extension',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'stats': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            _.forEach(nestedAgg, function(v, k) {
              agg[aggPrefix + 'totals'].aggs[k] = v;
            });
          }

          return agg;
        },
        _getDuplicatesAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};
          agg[aggPrefix + 'known'] = {
            'terms':{
              'field':'content.unique'
            },
            'aggs':{
              'total_size':{
                'sum':{
                  'field':'metadata.size'
                }
              }
            }
          };

          agg[aggPrefix + 'unknown'] = {
            'aggs':{
              'total_size':{
                'sum':{
                  'field':'metadata.size'
                }
              }
            },
            'missing':{
              'field':'content.unique'
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'known'].aggs = nestedAgg;
            agg[aggPrefix + 'unknown'].aggs = nestedAgg;
          }

          return agg;
        },
        _getPermissionsAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};
          agg[aggPrefix + 'totals'] = {
            'terms':{
              'field': 'permissions.allow',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'stats': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            _.forEach(nestedAgg, function(v, k) {
              agg[aggPrefix + 'totals'].aggs[k] = v;
            });
          }

          return agg;
        },
        _getArchiveStatusAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};
          agg[aggPrefix + 'archived'] = {
            'filter': {
              'exists': {
                'field': 'archive_complete'
              }
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };
          agg[aggPrefix + 'not_archived'] = {
            'filter': {
              'missing': {
                'field': 'archive_complete'
              }
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'archived'].aggs = nestedAgg;
            agg[aggPrefix + 'not_archived'].aggs = nestedAgg;
          }

          return agg;
        },
        _getFileSizeAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};

          agg[aggPrefix + 'file_size'] = {
            'range' : {
              'field': 'metadata.size',
              'ranges' : [
                {
                  'key':'small',
                  'to': (1024 * 1024 * 1024) - 1
                },
                {
                  'key': 'medium',
                  'from' : 1024 * 1024 * 1024,
                  'to': (1024 * 1024 * 1024 * 10) - 1
                },
                {
                  'key': 'large',
                  'from': 1024 * 1024 * 1024 * 10
                }
              ]
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'file_size'].aggs = nestedAgg;
          }

          return agg;
        },
        _getPlacesPersonAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};

          agg[aggPrefix + 'places_person'] = {
            'terms':{
              'field': 'content.person.value',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'places_person'].aggs = nestedAgg;
          }

          return agg;
        },
        _getPlacesOrganisationAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};

          agg[aggPrefix + 'places_organisation'] = {
            'terms':{
              'field': 'content.organisation.value',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'places_organisation'].aggs = nestedAgg;
          }

          return agg;
        },
        _getPlacesLocationAgg: function(aggPrefix, nestedAgg) {
          if (aggPrefix === undefined) {
            aggPrefix = '';
          }

          var agg = {};

          agg[aggPrefix + 'places_location'] = {
            'terms':{
              'field': 'content.location.value',
              'size': this._getSizeAgg()
            },
            'aggs': {
              'total_size': {
                'sum': {
                  'field': 'metadata.size'
                }
              }
            }
          };

          if (nestedAgg) {
            agg[aggPrefix + 'places_location'].aggs = nestedAgg;
          }

          return agg;
        },
        _getNestedDimensionData: function(agg) {
          var nested_dimension;
          var nested_agg = {};
          var nested_keys = _.chain(agg).keys()
            .filter(function(item) {
              return _.startsWith(item, 'nested');
            })
            .map(function(item) {
              return item.replace('nested_', '');
            })
            .value();

          _.forEach(this._dimensionKeys, function(item) {
            if (_.startsWith(nested_keys[0], item)) {
              nested_dimension = item;
              return false;
            }
          }, this);

          _.chain(nested_keys).map(function(item) {
            return item.replace(nested_dimension + '_', '');
          }).forEach(function(key) {
            nested_agg[key] = agg['nested_' + nested_dimension + '_' + key];
          }).value();

          if (nested_dimension) {
            return this._methodsMap[nested_dimension].postProcess(nested_agg);
          } else {
            return {
              term: agg.key,
              count: agg.doc_count,
              total: agg.total_size.sum ? agg.total_size.sum : agg.total_size.value
            };
          }
        },
        _getSizeAgg: function() {
          return (this.bVisualisationMap.indexOf(this.visualisation) !== -1) ? this.bidimensionalSizeAgg : 0;
        },
        _processLocationData: function(aggs) {
          var results = [];
          var data;
          var nested_data;

          _.forEach(aggs.buckets.buckets, function(item) {
            var size = filesize(item.total_size.sum, {output: 'array'});
            data = {
              filterType: 'dirpath',
              term: item.key,
              count: item.total_size.count,
              total: item.total_size.sum,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          var item = aggs.files_in_dir;
          if (item.total_size.count) {
            var size = filesize(item.total_size.sum, {output: 'array'});
            data = {
              term: '{files in directory}',
              count: item.total_size.count,
              total: item.total_size.sum,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processDocTypeData: function(aggs) {
          var results = [];
          var data;
          var nested_data;

          _.forEach(aggs.totals.buckets, function(item) {
            var size = filesize(item.total_size.sum, {output: 'array'});
            data = {
              filterType: 'doc_type',
              term: item.key,
              count: item.total_size.count,
              total: item.total_size.sum,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processExtensionData: function(aggs) {
          var results = [];
          var data;
          var nested_data;

          _.forEach(aggs.totals.buckets, function(item) {
            var size = filesize(item.total_size.sum, {output: 'array'});
            data = {
              filterType: 'extension',
              term: item.key,
              count: item.total_size.count,
              total: item.total_size.sum,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processDuplicatesData: function(aggs) {
          var results = [];
          var size;
          var total;
          var data;
          var nested_data;

          _.forEach(aggs.known.buckets, function(item) {
            size = [0, 'B'];
            total = 0;

            if (item.total_size) {
              size = filesize(item.total_size.value, {output: 'array'});
              total = item.total_size.value;
            }

            var term;
            if (item.key === 'T') {
              term = 'unique';
            } else if (item.key === 'F') {
              term = 'not_unique';
            }
            data = {
              filterType: 'unique',
              term: term,
              count: item.doc_count,
              total: total,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              if (nested_data.term === 'T') {
                nested_data.key = 'unique';
              } else if (nested_data.term === 'F') {
                nested_data.key = 'not_unique';
              }
              data.nestedDimension = nested_data;
            }

            if (data.count > 0) {
              results.push(data);
            }
          }, this);

          // unknown
          var item = aggs.unknown;
          size = [0, 'B'];
          total = 0;

          if (item.total_size) {
            size = filesize(item.total_size.value, {output: 'array'});
            total = item.total_size.value;
          }

          data = {
            filterType: 'unique',
            term: 'unknown',
            count: item.doc_count,
            total: total,
            size_human: size[0],
            size_human_measure: size[1]
          };

          nested_data = this._getNestedDimensionData(item);
          if (nested_data) {
            data.nestedDimension = nested_data;
          }

          if (data.count > 0) {
            results.push(data);
          }

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processPermissionsData: function(aggs) {
          var results = [];
          var data;
          var nested_data;

          _.forEach(aggs.totals.buckets, function(item) {
            var size = filesize(item.total_size.sum, {output: 'array'});
            data = {
              filterType: 'allow',
              term: item.key,
              count: item.total_size.count,
              total: item.total_size.sum,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }
            results.push(data);

          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processArchiveStatusData: function(aggs) {
          var results = [];
          var data;
          var nested_data;
          var item = aggs.archived;
          var size = [0, 'B'];
          var total = 0;

          // total_size object won't exists when archive_status is the parent dimension
          // data to be used resides on subaggregation
          if (item.total_size) {
            size = filesize(item.total_size.value, {output: 'array'});
            total = item.total_size.value;
          }

          data = {
            filterType: 'archive_status',
            term: 'archived',
            count: item.doc_count,
            total: total,
            size_human: size[0],
            size_human_measure: size[1]
          };

          nested_data = this._getNestedDimensionData(item);
          if (nested_data) {
            data.nestedDimension = nested_data;
          }

          if (data.count > 0) {
            results.push(data);
          }

          item = aggs.not_archived;
          size = [0, 'B'];
          total = 0;

          if (item.total_size) {
            size = filesize(item.total_size.value, {output: 'array'});
            total = item.total_size.value;
          }

          data = {
            filterType: 'archive_status',
            term: 'not_archived',
            count: item.doc_count,
            total: total,
            size_human: size[0],
            size_human_measure: size[1]
          };
          nested_data = this._getNestedDimensionData(item);
          if (nested_data) {
            data.nestedDimension = nested_data;
          }

          if (data.count > 0) {
            results.push(data);
          }

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processFileSizeData: function(aggs) {
          var results = [];
          var size;
          var total;
          var data;
          var nested_data;

          _.forEach(aggs.file_size.buckets, function(item) {
            size = [0, 'B'];
            total = 0;

            if (item.total_size) {
              size = filesize(item.total_size.value, {output: 'array'});
              total = item.total_size.value;
            }

            data = {
              filterType: 'file_size',
              term: item.key,
              count: item.doc_count,
              total: total,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            if (data.count > 0) {
              results.push(data);
            }
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processPlacesPersonData: function(aggs) {
          var results = [];
          var size;
          var total;
          var data;
          var nested_data;

          _.forEach(aggs.places_person.buckets, function(item) {
            size = [0, 'B'];
            total = 0;

            if (item.total_size) {
              size = filesize(item.total_size.value, {output: 'array'});
              total = item.total_size.value;
            }

            data = {
              filterType: 'places_person',
              term: item.key,
              count: item.doc_count,
              total: total,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processPlacesOrganisationData: function(aggs) {
          var results = [];
          var size;
          var total;
          var data;
          var nested_data;

          _.forEach(aggs.places_organisation.buckets, function(item) {
            size = [0, 'B'];
            total = 0;

            if (item.total_size) {
              size = filesize(item.total_size.value, {output: 'array'});
              total = item.total_size.value;
            }

            data = {
              filterType: 'places_organisation',
              term: item.key,
              count: item.doc_count,
              total: total,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _processPlacesLocationData: function(aggs) {
          var results = [];
          var size;
          var total;
          var data;
          var nested_data;

          _.forEach(aggs.places_location.buckets, function(item) {
            size = [0, 'B'];
            total = 0;

            if (item.total_size) {
              size = filesize(item.total_size.value, {output: 'array'});
              total = item.total_size.value;
            }

            data = {
              filterType: 'places_location',
              term: item.key,
              count: item.doc_count,
              total: total,
              size_human: size[0],
              size_human_measure: size[1]
            };

            nested_data = this._getNestedDimensionData(item);
            if (nested_data) {
              data.nestedDimension = nested_data;
            }

            results.push(data);
          }, this);

          results = this._setObjectPercentage(results);

          this.requestInProgress = false;

          return results;
        },
        _buildTwoDimensionMatrix: function(data) {
          var relationDoesNotExists = true;
          var results = {
            data: [],
            labels: []
          };

          var masterDimensions = [];
          var nestedDimensions = [];

          _.forEach(data, function (masterItem) {
            // For a given agg, a subagg may be empty, if so, relation does not exists
            // and empty result set can be returned
            _.forEach(masterItem.nestedDimension, function (slaveItem) {
              relationDoesNotExists = false;
              nestedDimensions.push({
                term: slaveItem.term,
                group: 2
              });
            });

            masterDimensions.push({
              term: masterItem.term,
              group: 1
            });
          });

          if (relationDoesNotExists) {
            return results;
          }

          nestedDimensions = _.uniq(_.union(nestedDimensions), 'term');

          var masterDimensionCounter = 0;
          _.forEach(data, function (masterItem) {
            var nestedDimensionsHelper = [];
            for (var i = 0; i < nestedDimensions.length; i++) {
              var index = _.chain(masterItem.nestedDimension)
                .pluck('term')
                .indexOf(nestedDimensions[i].term).value();

              var count = 0;
              var total = 0;
              if (index !== -1) {
                count = masterItem.nestedDimension[index].count;
                total = masterItem.nestedDimension[index].total;
              }

              nestedDimensionsHelper.push({
                term: nestedDimensions[i],
                count: count,
                total: total
              });
            }

            data[masterDimensionCounter].nestedDimension = nestedDimensionsHelper;
            masterDimensionCounter++;
          });

          var matrixLength = nestedDimensions.length + data.length;
          var i;
          var j;

          for (i = 0; i < matrixLength; i++) {
            results.data[i] = [];
            for (j = 0; j < matrixLength; j++) {
              results.data[i][j] = {};
            }
          }

          /* Fill dead quadrants (master / master and slave / slave)*/
          for (i = 0; i < data.length; i++) {
            for (j = 0; j < data.length; j++) {
              results.data[i][j] = {
                count: 0,
                total: 0
              };
            }
          }

          for (i = data.length; i < matrixLength; i++) {
            for (j = data.length; j < matrixLength; j++) {
              results.data[i][j] = {
                count: 0,
                total: 0
              };
            }
          }

          /* Fill quadrants which could have data assigned to them
           (master / slave and slave / master) */
          for (i = 0; i < data.length; i++) {
            for (j = data.length; j < matrixLength; j++) {
              results.data[i][j] = {
                count: data[i].nestedDimension[j - data.length].count,
                total: data[i].nestedDimension[j - data.length].total
              };
            }
          }

          for (i = data.length; i < matrixLength; i++) {
            for (j = 0; j < data.length; j++) {
              results.data[i][j] = {
                count: data[j].nestedDimension[i - data.length].count,
                total: data[j].nestedDimension[i - data.length].total
              };
            }
          }

          results.labels = masterDimensions.concat(nestedDimensions);
          //this._outputTable('two dimension', results);
          return results;
        },
        _buildSingleDimensionMatrix: function(data) {
          var results = {
            data: [],
            labels: []
          };
          var masterDimensions = [];
          var slaveDimensions = [];

          var i;
          var j;

          for (i = 0; i < data.length; i++) {
            results.data[i] = [];
            for (j = 0; j < data.length; j++) {
              results.data[i][j] = {};
            }
          }

          _.forEach(data, function(item) {
            masterDimensions.push({
              term: item.term,
              group: 1
            });
          });

          for (i = 0; i < data.length; i++) {
            for (j = 0; j < data.length; j++) {
              var count = 0;
              var total = 0;
              if (i === j) {
                count = data[i].nestedDimension.count;
                total = data[i].nestedDimension.total;
              }
              results.data[i][j] = {
                count: count,
                total: total
              };
            }
          }
          results.labels = masterDimensions.concat(slaveDimensions);

          return results;
        },
        attached: function() {
          Polymer.dom.flush();

          var that = this;

          this._methodsMap = {
            location: {
              buildAggs: that._getLocationAgg.bind(that),
              postProcess: that._processLocationData.bind(that)
            },
            doc_type: {
              buildAggs: that._getDocTypeAgg.bind(that),
              postProcess: that._processDocTypeData.bind(that)
            },
            extension: {
              buildAggs: that._getExtensionAgg.bind(that),
              postProcess: that._processExtensionData.bind(that)
            },
            duplicates: {
              buildAggs: that._getDuplicatesAgg.bind(that),
              postProcess: that._processDuplicatesData.bind(that)
            },
            allow: {
              buildAggs: that._getPermissionsAgg.bind(that),
              postProcess: that._processPermissionsData.bind(that)
            },
            archive_status: {
              buildAggs: that._getArchiveStatusAgg.bind(that),
              postProcess: that._processArchiveStatusData.bind(that)
            },
            file_size: {
              buildAggs: that._getFileSizeAgg.bind(that),
              postProcess: that._processFileSizeData.bind(that)
            },
            places_person: {
              buildAggs: that._getPlacesPersonAgg.bind(that),
              postProcess: that._processPlacesPersonData.bind(that)
            },
            places_organisation: {
              buildAggs: that._getPlacesOrganisationAgg.bind(that),
              postProcess: that._processPlacesOrganisationData.bind(that)
            },
            places_location: {
              buildAggs: that._getPlacesLocationAgg.bind(that),
              postProcess: that._processPlacesLocationData.bind(that)
            }
          };

          this._dimensionKeys = _.keys(this._methodsMap);

          // Selects its filter converter, if not,
          // the one from kazoup-search can be selected erroneously
          // trigerring observer in the wrong place
          this._filterConverter = Polymer.dom(document)
            .querySelector(this.target)
            .querySelector('#filterConverter');
          this._filterConverter.addEventListener('filters-changed', this._handleFilterChanged.bind(this));
        }
      });
    }());
  </script>
</dom-module>
