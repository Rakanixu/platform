<link rel='import' href='../../bower_components/lib-d3/lib-d3.html'>
<link rel="import" href="../kazoup-empty-state/kazoup-empty-state.html">
<link rel="import" href="../kazoup-d3-tip-import/kazoup-d3-tip-import.html">

<dom-module id="kazoup-d3-histogram">
  <link rel="import" type="css" href="kazoup-d3-histogram.css">

  <template>

    <div class="timestamp-container">
      <span data-timestamp-type="accessed"
            on-tap="setTimestampType">Accessed</span> |
      <span data-timestamp-type="modified"
            on-tap="setTimestampType">Modified</span>
    </div>

    <div id="chart" class="bar_chart">
      <kazoup-empty-state class="chart" icon="" header="No data" description="<span>Just point Kazoup
        at your network and data. Start analyzing by configuring your </span>
        <a href='/settings?section=sources'> data sources</a>
        <span> and </span><a href='/settings?section=conf'>network access</a>
        <span> in Settings.</span>" hidden$="[[!histogramEmptyStateVisible]]"></kazoup-empty-state>

      <!-- title tag is important due to html minification; <svg></svg> -> <svg/> -->
      <!-- We force the minifier to not transform the tag by adding a children -->
      <svg id="paper"><title>svg</title></svg>
    </div>

  </template>
  <script>
    'use strict';

    (function() {
      Polymer({
        is: 'kazoup-d3-histogram',
        behaviors: [KazoupBehaviors.Util],
        properties: {
          histogramData: {
            type: Object,
            notify: true,
            observer: 'histogramDataChanged'
          },
          histogramEmptyStateVisible: {
            type: Boolean,
            value: false
          },
          period: {
            type: String,
            notify: true
          },
          timestampType: {
            type: String,
            notify: false
          }
        },
        histogramDataChanged: function(newValue, oldValue) {
          //Avoid to show empty state on first load
          if (oldValue === undefined && newValue.length === 0) {
            this.histogramEmptyStateVisible = false;
          } else {
            this.histogramEmptyStateVisible = !newValue.length;
            this.prepare();
          }
        },
        prepare: function() {
          var bounds = Polymer.dom(document)
            .querySelector('kazoup-analytics')
            .querySelector('.histogram-chart')
            .getBoundingClientRect();
          var svg = d3.select(this.$.paper);

          //clear svg and ensure namespace
          svg.attr('version', '1.1').attr('xmlns', 'http://www.w3.org/2000/svg');
          svg.selectAll('*').remove();
          svg.attr('width', bounds.width);
          svg.attr('height', bounds.height);

          this.renderBarChart(svg, this.histogramData, bounds.width, bounds.height);
        },
        renderBarChart: function(svg, data, width, height) {
          var _self = this;
          var margin = {
            top: 100,
            right: 80,
            bottom: 0,
            left: 60
          };

          var tip = d3.tip().offset([
            -10,
            0
          ]).html(function(d) {
            var date;

            if (this.period === 'year') {
              date = '<b>Year: </b>' + new Date(d.time).getUTCFullYear();
            } else if (this.period === 'month') {
              date = '<b>Month: </b>' + _self.formatMonthYear(d.time);
            } else if (this.period === 'day') {
              date = '<b>Day: </b>' + _self.formatDayMonthYear(d.time);
            }

            return '<div class="d3-tip">' +
              '<b>Size: </b>' + d.size_human + ' ' + d.size_human_measure + '<br>' + date +
              '</div>';
          }.bind(this));

          var selection = svg;
          selection.attr('width', width);
          selection.attr('height', height - 10);
          var xScale, yScale, xAxis, yAxis;

          function chart(selection) {
            selection.call(tip);
            selection.each(function(data) {
              height -= margin.top;
              width -= margin.right;
              var barScale = d3.scale.ordinal().rangeRoundBands([
                0,
                width
              ], 0.45).domain(data.map(function(d) {
                return d.time;
              }));
              var values = _.filter(data, function(item) {
                return item.total > 0;
              });
              if (!values.length) {
                return;
              }

              var minDate = data[0];
              var maxDate = data[data.length - 1];
              var ticks = _self.period === 'year' ? Math.min(7, data.length) : Math.min(4, data.length);

              xScale = d3.time.scale().rangeRound([
                barScale(minDate.time),
                barScale(maxDate.time)
              ]);
              xScale.rangeBand = function() {
                return barScale.rangeBand();
              };
              yScale = d3.scale.linear().rangeRound([
                height,
                0
              ]).clamp(true);
              yAxis = d3.svg.axis().scale(yScale).ticks(4).tickFormat(function(d) {
                return d;
              }).orient('left');

              var container = d3.select(this);
              var wrap = container.selectAll('g.margin-contained').data([data]);

              // anything that uses gEnter will only happen once (due to the data binding),
              // when the chart is created for the first time
              var gEnter = wrap
                .enter()
                .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + 60 + ')');

              chart.update = function() {
                selection.call(chart);
              };

              var bytes_conversion_factor = function(fileSizeInBytes) {
                var i = -1;
                var factor = 1024;
                var byteUnits = [
                  'kB',
                  'MB',
                  'GB',
                  'TB',
                  'PB',
                  'EB',
                  'ZB',
                  'YB'
                ];
                do {
                  fileSizeInBytes = fileSizeInBytes / 1024;
                  i++;
                  if (i > 0) {
                    factor = factor * 1024;
                  }
                } while (fileSizeInBytes > 512);
                return {
                  conversion_factor: factor,
                  'unit_label': byteUnits[i]
                };
              };

              var byteConversion = bytes_conversion_factor(_.max(data, function(item) {
                return item.total;
              }).total);

              // update scale domains with actual data
              var firstDate = data[0];
              var lastDate = data[data.length - 1];
              firstDate = new Date(firstDate.time);
              lastDate = new Date(lastDate.time);
              xScale.domain([
                firstDate,
                lastDate
              ]).nice();
              yScale.domain([
                0,
                d3.max(data, function(d) {
                  return d.total / byteConversion.conversion_factor;
                })
              ]).nice();

              // draw x axis grid lines
              var gridlines = gEnter.append('g').attr('class', 'gridlines');
              gridlines.append('g').attr('class', 'gridlinesX');
              gridlines.append('g').attr('class', 'gridlinesY');
              var gridlinesX = wrap.select('.gridlinesX');
              var gridlinesY = wrap.select('.gridlinesY');
              var gridlinesXJoin = gridlinesX.selectAll('line.x').data(yScale.ticks(yAxis.ticks()[0]));

              gridlinesXJoin
                .enter()
                .append('line')
                .attr('class', 'x')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', 0)
                .attr('y2', 0)
                .style('stroke', '#d9d9d9')
                .attr('stroke-opacity', 0.000001);

              // new lines are invisible on entry
              gridlinesXJoin
                .exit()
                .transition()
                .duration(1000)
                .attr('y1', 0)
                .attr('y2', 0)
                .attr('stroke-opacity', 0.000001)
                .remove();

              gridlinesXJoin
                .transition()
                .duration(1000)
                .attr('x2', width)
                .attr('stroke-opacity', 1)
                .attr('y1', function(d) {
                  return yScale(d);
                }).attr('y2', function(d) {
                  return yScale(d);
                });

              var gridlinesYJoin = gridlinesY.selectAll('line.y').data(data, function(d) {
                return d.time;
              });

              xAxis = d3.svg.axis().ticks(ticks).scale(xScale).tickFormat(function(d) {
                var date = new Date(d);
                if (this.period === 'year') {
                  return date.getFullYear();
                } else if (this.period === 'month') {
                  return _self.formatMonthYear(date.getTime());
                } else if (this.period === 'day') {
                  return _self.formatDayMonthYear(date.getTime());
                }
              }.bind(_self)).orient('bottom');

              // add bars
              gEnter.append('g').attr('class', 'bars');
              var barsJoin = wrap.select('g.bars').selectAll('rect.bar').data(data, function(d) {
                return d.time;
              });

              barsJoin
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', function(d) {
                  return barScale(d.time);
                })
                .attr('width', barScale.rangeBand())
                .attr('height', 0).attr('y', 0)
                .style('fill', '#1EB3DA')
                .style('stroke', '#1EB3DA')
                .on('mouseover', tip.show)
                .on('mouseout', tip.hide);

              barsJoin
                .transition()
                .duration(1000)
                .attr('x', function(d) {
                  return barScale(d.time);
                })
                .attr('width', barScale.rangeBand())
                .attr('y', function(d) {
                  return yScale(d.total / byteConversion.conversion_factor);
                })
                .attr('height', function(d) {
                  if (height - yScale(d.total / byteConversion.conversion_factor) > 0) {
                    return height - yScale(d.total / byteConversion.conversion_factor);
                  } else {
                    return 0;
                  }
                });

              barsJoin
                .exit()
                .transition()
                .duration(1000)
                .attr('y', height)
                .attr('height', 0).remove();

              // add x axis
              gEnter
                .append('g')
                .attr('class', 'xaxis axis')
                .attr('transform', 'translate(' + barScale.rangeBand() / 2 + ',' + height + ')')
                .call(xAxis);

              wrap
                .select('.xaxis')
                .transition()
                .duration(1000)
                .call(xAxis);

              // add y axis
              gEnter
                .append('g')
                .attr('class', 'yaxis axis')
                .attr('transform', 'translate(0, 0)')
                .call(yAxis);

              wrap
                .select('.yaxis')
                .transition()
                .duration(1000)
                .call(yAxis);

              // add x axis label
              gEnter
                .append('text')
                .attr('class', 'xlabel')
                .attr('fill', '#444')
                .attr('text-anchor', 'middle')
                .attr('x', -18)
                .attr('y', -25);

              if (wrap.select('.xlabel').text() !== byteConversion.unit_label) {
                wrap
                  .select('.xlabel')
                  .transition()
                  .duration(500)
                  .attr('opacity', 0)
                  .attr('fill', '#444')
                  .transition()
                  .duration(500)
                  .text(byteConversion.unit_label)
                  .attr('opacity', 1);
              }
            });
          }

          if (this.histogramData) {
            selection.datum(this.histogramData);
            chart(selection);
          }
        },
        setTimestampType: function(e, detail) {
          this.set('timestampType', e.target.dataset.timestampType);

          // Clear from and to when timestamp type dimension changes
          this._filterConverter.setValues([
            {
              field: 'timestampType',
              val: this.timestampType
            }
          ]);
        },
        _handleTimestampChanged: function(e) {
          var elements = Polymer.dom(this.root).querySelectorAll('.timestamp-container span');

          this.set('timestampType', this._filterConverter.getValue('timestampType'));

          _.forEach(elements, function(el) {
            el.classList.remove('selected');
          }, this);

          Polymer.dom(this.root)
            .querySelector('.timestamp-container span[data-timestamp-type="' + this.timestampType + '"]')
            .classList.add('selected');
        },
        attached: function() {
          var resizeCallback;

          Polymer.dom.flush();

          this._filterConverter = Polymer.dom(document)
            .querySelector('kazoup-analytics')
            .querySelector('#filterConverter');
          this._filterConverter.addEventListener('filters-changed', this._handleTimestampChanged.bind(this));

          window.addEventListener('resize', function() {
            clearTimeout(resizeCallback);
            resizeCallback = setTimeout(function() {
              this.prepare();
            }.bind(this), 200);
          }.bind(this));
        }
      });
    }());
  </script>
</dom-module>
