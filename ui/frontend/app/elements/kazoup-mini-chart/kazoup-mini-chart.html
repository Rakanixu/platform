<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../kazoup-empty-state/kazoup-empty-state.html">

<dom-module id="kazoup-mini-chart">
  <link rel="import" type="css" href="kazoup-mini-chart.css">
  <template>

    <div class="container layout vertical">
      <div id="pieLabel" class="vertical layout">
        <span id="label" class="flex">[[label]]</span>
        <span id="subLabel" class="flex">[[subLabel]]</span>
      </div>
      <div id="chartContainer"></div>

      <kazoup-empty-state hidden$="{{!noData}}"
                          icon="settings"
                          header="No data"
                          description="<span>Just point Kazoup
        at your network and data. Start analyzing by configuring your </span><a href='/settings?section=sources'>
        data sources</a><span> and </span><a href='/settings?section=conf'>network access</a>
        <span> in Settings.</span>"></kazoup-empty-state>
    </div>

  </template>
  <script src="../../bower_components/Chart.js/Chart.min.js"></script>
  <script>
    'use strict';

    (function() {
      Polymer({
        is: 'kazoup-mini-chart',
        behaviors: [KazoupBehaviors.Util],
        properties: {
          dataChart: {
            type: Object,
            notify: true,
            observer: 'dataChartChanged'
          },
          noData: {
            type: Boolean,
            notify: true,
            value: false
          },
          options: {
            type: Object,
            notify: true
          },
          type: {
            type: String,
            notify: true
          },
          labelText: {
            type:String,
            notify: false
          },
          labelValue: {
            type:String,
            notify: false
          },
          labelValueInfo: {
            type:String,
            notify: false
          },
          label: {
            type: String,
            notify: false,
            value: ''
          },
          subLabel: {
            type: String,
            notify: false,
            value: ''
          }
        },
        /**
         * Observer @dataChart
         * Draws a chart when data is ready
         */
        dataChartChanged: function() {
          this.$.pieLabel.style.opacity = 0;

          if (this.dataChart instanceof Array) {
            (!this.dataChart.length) ? this.noData = true : this.noData = false;
          } else {
            (this.dataChart && this.dataChart.labels instanceof Array && !this.dataChart.labels.length) ?
                this.noData = true : this.noData = false;
          }

          if (!this.noData) {
            this.injectBoundHTML(
              '<canvas id="chart"></canvas>',
              this.$.chartContainer
            );

            this.destroy();
            this.async(function() {
              this[this.type]();
            }, 200);
          } else {
            this.$.chartContainer.querySelector('canvas').style.display = 'none';
          }
        },
        /**
         * Render a canvas based line chart
         */
        renderLineChart: function() {
          var _self = this;
          var lineChart = this.$.chartContainer.querySelector('canvas').getContext('2d');
          var lineOptions = {
            tooltipTemplate: function (valuePayload) {
              if (_self.options.yAxis === 'size') {
                return filesize(parseInt(valuePayload.value));
              } else if (_self.options.yAxis === 'numberOfFiles') {
                return valuePayload.value;
              }
            },
            scaleLabel: function (valuePayload) {
              if (_self.options.yAxis === 'size') {
                return filesize(Number(valuePayload.value));
              } else if (_self.options.yAxis === 'numberOfFiles') {
                return valuePayload.value;
              }
            }
          };
          if (this.dataChart) {
            this.chart = new Chart(lineChart).Line(this.dataChart, lineOptions);
          }
        },
        /**
         * Render a canvas based bar chart
         */
        renderBarChart: function() {
          var _self = this;
          var barChart = this.$.chartContainer.querySelector('canvas').getContext('2d');
          var barOptions = {
            tooltipTemplate: function (valuePayload) {
              if (_self.options.yAxis === 'size') {
                return filesize(parseInt(valuePayload.value));
              } else if (_self.options.yAxis === 'numberOfFiles') {
                return valuePayload.value;
              } else if (_self.options.yAxis === 'numberOfSearch') {
                return valuePayload.value;
              }
            },
            scaleLabel: function (valuePayload) {
              if (_self.options.yAxis === 'size') {
                return filesize(Number(valuePayload.value));
              } else if (_self.options.yAxis === 'numberOfFiles') {
                return valuePayload.value;
              } else if (_self.options.yAxis === 'numberOfSearch') {
                return valuePayload.value;
              }
            }
          };
          if (this.dataChart) {
            this.chart = new Chart(barChart).Bar(this.dataChart, barOptions);
          }
        },
        /**
         * Render a canvas based pie chart
         */
        renderPieChart: function() {
          var doughnutChart = this.$.chartContainer.querySelector('canvas').getContext('2d');
          var doughnutOptions = {
            segmentShowStroke: false,
            animateScale: true,
            tooltipTemplate: '<%= label %>',
            customTooltips: function(tooltip) {
              var regex = new RegExp('[0-9]+[.]*[0-9]*');

              if (tooltip.text) {
                this.setPieLabel(
                  tooltip.text.substring(0, tooltip.text.match(regex).index),
                  tooltip.text.substring(tooltip.text.match(regex).index, tooltip.text.length)
                );
              } else {
                this.setPieLabel(this.labelText, this.labelValue + ' ' + this.labelValueInfo);
              }

              return;
            }.bind(this)
          };

          if (this.dataChart) {
            this.chart = new Chart(doughnutChart).Doughnut(this.dataChart, doughnutOptions);

            this.setPieLabel(this.labelText, this.labelValue + ' ' + this.labelValueInfo);
            this.$.pieLabel.style.opacity = 0.8;
          }
        },
        /**
         * Render a canvas based radar chart
         */
        renderRadarChart: function() {
          var _self = this;
          var radarChart = this.$.chartContainer.querySelector('canvas').getContext('2d');
          var radarOptions = {
            tooltipTemplate: function (valuePayload) {
              return filesize(parseInt(valuePayload.value));
            }
          };
          if (this.dataChart) {
            this.chart = new Chart(radarChart).Radar(this.dataChart, radarOptions);
          }
        },
        /**
         * Set label text
         */
        setPieLabel: function(label, subLabel) {
          this.set('label', label);

          if (subLabel) {
            this.set('subLabel', subLabel);
            this.$.label.style['margin-top'] = '0';
          } else {
            this.set('subLabel', '');
            this.$.label.style['margin-top'] = '15px';
          }
        },
        /**
         * Clear out canvas content
         */
        destroy: function() {
          if (this.chart) {
            this.chart.destroy();
          }
        },
        attached: function() {
          var resizeCallback;

          window.addEventListener('resize', function () {
            clearTimeout(resizeCallback);
            resizeCallback = setTimeout(function() {
              if (this.type) {
                this.destroy();
                this[this.type]();
              }
            }.bind(this), 200);
          }.bind(this));
        }
      });
    }());
  </script>
</dom-module>
