<dom-module id="kazoup-search-data">
  <script>
    (function() {
      var docTypeColorMap = {
        'eBook Files': '#7f8c8d',
        'GIS Files': '#7f8c8d',
        'Web Files': '#7f8c8d',
        'Disk Image Files': '#7f7f7f',
        'Page Layout Files': '#7f8c8d',
        'Data Files': '#17becf',
        'Document Files': '#1f77b4',
        'Game Files': '#7f8c8d',
        'CAD Files': '#7f8c8d',
        'Compressed Files': '#e377c2',
        'Email Files': '#7f8c8d',
        'Image Files': '#d62728',
        'System Files': '#7f8c8d',
        'PDF Files': '#ff7f0e',
        'Camera Raw Files': '#7f8c8d',
        'Text Files': '#7f8c8d',
        'Plugin Files': '#7f8c8d',
        'Spreadsheet Files': '#2ca02c',
        'Database Files': '#7f8c8d',
        'Developer Files': '#7f8c8d',
        'Executable Files': '#7f8c8d',
        'Audio Files': '#8c564b',
        'Settings Files': '#7f8c8d',
        'Video Files': '#9467bd',
        'Misc Files': '#7f8c8d',
        'Font Files': '#7f8c8d',
        'Backup Files': '#7f8c8d',
        'Encoded Files': '#7f8c8d'
      };
      // This is a slightly modified version of angular.js $q.all() from
      // https://github.com/angular/angular.js/blob/master/src/ng/q.js#L538.
      // It uses pinkyswear.js (a dependency of qwest) to provide the promise implementation.
      function all(promises) {
        var allPromise = pinkySwear();
        var counter = 0;
        var results = _.isArray(promises) ? [] : {};
        _.forEach(promises, function(promise, key) {
          counter++;
          promise.then(function(value) {
              if (results.hasOwnProperty(key)) {
                return;
              }
              results[key] = value;
              if (!--counter) {
                allPromise(true, [results]);
              }
            }, // resolve
            function(reason) {
              if (results.hasOwnProperty(key)) {
                return;
              }
              allPromise(false, reason);
            });
        });
        // reject
        if (counter === 0) {
          allPromise(true, [results]);
        }
        // resolve
        return allPromise;
      }
      /**
       * makes requests to elasticsearch based on dimension, post processes response, sets chartData & histogramData
       */
      Polymer({
        is: 'kazoup-search-data',
        behaviors: [
          KazoupBehaviors.NetworkError,
          KazoupBehaviors.APIUrls
        ],
        properties: {
          dirsCount: {
            type: Number,
            notify: false,
            value: function() {
              return -1;
            }
          },
          from: {
            type: Number,
            notify: false,
            value: 0
          },
          xhrPool: {
            type: Array,
            value: function() {
              return [];
            }
          },
          target: {
            type: String,
            notify:false
          },
          requestInProgress: {
            type: Boolean,
            notify: true
          },
          results: {
            type: Array,
            notify: true
          },
          tookStats: {
            type: Object,
            notify: true
          },
          scroll: {
            type: Number,
            notify: true,
            observer: 'scrollChanged'
          },
          browser: {
            type: Boolean,
            notify: true,
            observer: 'browserChanged'
          },
          firstLoad: {
            type: Boolean,
            notify: false,
            value: true
          }
        },
        scrollChanged: function(newVal, oldVal) {
          if (oldVal) {
            this.set('requestInProgress', true);
            this._getData();
          }
        },
        browserChanged: function(newVal, oldVal) {
          if (oldVal !== undefined) {
            this._filtersChanged();
          }
        },
        reset: function() {
          this.from = 0;
          this.dirsCount = -1;
          this.set('results', []);
          this.set('tookStats', {
            took: undefined,
            fileResults: undefined,
            directoryResults: undefined
          });
        },
        _filtersChanged: function(e) {
          // When load first time, filterConverter fires twice the fire-changed event
          // Due to setting up the object and the params from URL
          // On firts load, we avoid to generate extra requests
          if (!this.firstLoad) {
            this.set('requestInProgress', true);
            this.reset();
            // Cancel requests which has been initialize but not resolved yet
            this._abortOnGoingRequests();
            // Initialize request
            this._getData();
          } else {
            this.firstLoad = !this.firstLoad;
          }
        },
        _abortOnGoingRequests: function() {
          // Aborts all ongoing requests
          if (this.xhrPool.length) {
            _.forEach(this.xhrPool, function(xhr) {
              // Check if request did finish, and aboirt if is on going
              if (xhr.readyState !== 4) {
                xhr.abort();
              }
            });
            this.xhrPool = [];
          }
        },
        _getData: function() {
          if (this.browser) {
            if (this.dirsCount === -1) {
              this._getBrowserResults();
            } else if (this.dirsCount > -1) {
              this._getMoreBrowserResults();
            }
          } else {
            this._getSearchResults();
          }
        },
        _getBrowserResults: function() {
          var dirsPromise = this._makeDirectoryRequest();
          var filesInDirPromise = this._makeFilesInDirectoryRequest();

          all([
            dirsPromise,
            filesInDirPromise
          ]).then(function(resultsArray) {
            this.set('results', resultsArray[0].aggregations.dirs.buckets.concat(resultsArray[1].hits.hits));

            this.dirsCount = resultsArray[0].aggregations.dirs.buckets.length;
            this.from = resultsArray[1].hits.hits.length;

            // size of files in dir results
            this.set('tookStats', {
              took: resultsArray[0].took + resultsArray[1].took,
              fileResults: resultsArray[1].hits.total,
              directoryResults: resultsArray[0].aggregations.dirs.buckets.length
            });

            this.set('requestInProgress', false);
          }.bind(this));
        },
        _getMoreBrowserResults: function() {
          if (this.results.length >= this.tookStats.fileResults + this.dirsCount) {
            this.set('requestInProgress', false);
            // no more results available
            return;
          }

          // we've already got the dirs, we just next the next files
          this._makeFilesInDirectoryRequest().then(function(results) {
            _.forEach(results.hits.hits, function(result) {
              this.push('results', result);
            }, this);

            this.from = this.from + results.hits.hits.length;

            // size of files in dir results
            this.set('tookStats', {
              took: results.took,
              fileResults: results.hits.total,
              directoryResults: this.tookStats.directoryResults
            });

            this.set('requestInProgress', false);
          }.bind(this));
        },
        _getSearchResults: function() {
          if (this.results.length >= this.tookStats.fileResults) {
            this.set('requestInProgress', false);
            // no more results available
            return;
          }

          this._makeSearchRequest().then(function(results) {
            this.set('tookStats', {
              took: results.took,
              fileResults: results.hits.total,
              directoryResults: undefined
            });
            
            // Reset results if we detect first item is a directory.
            if (this.results.length) {
              if (this.results[0].hasOwnProperty('doc_count')) {
                this.set('results', []);
              }
            }

            this.from = this.results.length;

            _.forEach(results.hits.hits, function(result) {
              this.push('results', result);
            }, this);

            this.set('requestInProgress', false);
          }.bind(this));
        },
        _makeSearchRequest: function() {
          var q = this._filterConverter.getValue('q');
          var sort = this._filterConverter.getValue('sort');
          var checksum = this._filterConverter.getValue('checksum');
          var searchQuery = {};
          var _self = this;
          var query = {
            size: 20,
            from: this.from,
            query: {
              filtered: {
                filter: {
                  bool: {
                    must: [
                      {
                        'bool': {
                          'should': [
                            {
                              'term': {
                                'exists_on_disk': true
                              }
                            },
                            {
                              'exists': {
                                'field': 'archive_complete'
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              }
            }
          };

          // Content search is enabled by default, so, if user do not set the flag,
          // value in localStorage is null, but by default, enabled.
          if ((localStorage.getItem('advance_content_search_enabled') === 'true' ||
            localStorage.getItem('advance_content_search_enabled') === null) && q) {
            searchQuery = {
              multi_match: {
                query: q,
                type: 'most_fields',
                operator: 'or',
                fields: [
                  'metadata.filename',
                  'content.text'
                ]
              }
            };
            var highlight = {
              fields: {
                'content.text': {
                  fragment_size: 150,
                  number_of_fragments: 1
                }
              }
            };
            query.query.filtered.query = searchQuery;
            query['highlight'] = highlight;
          } else if (localStorage.getItem('advance_content_search_enabled') === 'false' && q) {
            searchQuery = {
              bool: {
                must: [{
                  bool: {
                    should: [
                      {
                        match: {
                          'metadata.filename': {
                            type: 'phrase',
                            boost: 2,
                            query: q
                          }
                        }
                      },
                      {
                        match: {
                          'metadata.filename': q
                        }
                      }
                    ]
                  }
                }]
              }
            };
            query.query.filtered.query = searchQuery;
          }

          if (sort && sort.length) {
            var sortBy = {};
            query.sort = [];
            if (sort === '_score') {
              query.sort.push(sort);
            } else {
              sortBy[sort] = 'desc';
              query.sort.push(sortBy);
            }
          }

          query.query.filtered.filter.bool.must.push(this._filterConverter.asElasticsearchFilters('q'));

          return qwest.post(
            this.endpointList.ESFiles,
            {
              index: "files",
              type: "file",
              query: query
            },
            {
              dataType: 'json',
              cache: true,
              headers: {
                Accept: 'application/json',
                Authorization: 'JWT ' + localStorage.getItem('authToken')
              }
            }, function(xhr) {
              // Push the XMLHttpRequest to be able to abort the request if necessary
              _self.xhrPool.push(xhr);
            }).then(function(xhr, response) {
              _.forEach(response.hits.hits, function(item) {
                if (item.highlight && item.highlight['content.text']) {
                  item.highlight = item.highlight['content.text'][0];
                } else {
                  item.highlight = '';
                }

                // this has been added in files_v2, so can be removed at some point
                item.id_b64 = btoa(encodeURIComponent(item._id));
                try {
                  item.color = docTypeColorMap[item._source.metadata.doc_type];
                } catch (exc) {
                  item.color = '#ff7f0e';
                }
              });

              return response;
            }).catch(this.handleNetworkError);
        },
        _makeDirectoryRequest: function() {
          var dirpath = this._filterConverter.getValue('dirpath');
          var _self = this;
          var query = {
            size: 0,
            query: {
              constant_score: {
                filter: {
                  bool: {
                    must: [
                      {
                        'bool': {
                          'should': [
                            {
                              'term': {
                                'exists_on_disk': true
                              }
                            },
                            {
                              'exists': {
                                'field': 'archive_complete'
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              }
            },
            aggs: {
              dirs: {
                terms: {
                  field: 'metadata.dirpath_split.0',
                  size: 0,
                  order: {
                    'size_data.sum': 'desc'
                  }
                },
                aggs: {
                  size_data: {
                    stats: {
                      field: 'metadata.size'
                    }
                  }
                }
              }
            }
          };

          query.query.constant_score.filter.bool.must.push(this._filterConverter.asElasticsearchFilters());

          if (dirpath.length) {
            // we want 1 or greater
            query.aggs.dirs.terms.field = 'metadata.dirpath_split.' + _.max([
                _.trim(dirpath[0], '/').split('/').length,
                1
              ]);
          } else {
            query.aggs.dirs.terms.field = 'metadata.dirpath_split.1';
          }

          return qwest.post(
            this.endpointList.ESFiles,
            {
              index: "files",
              type: "file",
              query: query
            },
            {
              dataType: 'json',
              cache: true,
              headers: {
                Accept: 'application/json',
                Authorization: 'JWT ' + localStorage.getItem('authToken')
              }
            },
            function(xhr) {
              // Push the XMLHttpRequest to be able to abort the request if necessary
              _self.xhrPool.push(xhr);
            }).then(function(xhr, response) {
              return response;
            }).catch(this.handleNetworkError);
        },
        _makeFilesInDirectoryRequest: function() {
          var dirpath = _.isEmpty(this._filterConverter.getValue('dirpath')) ?
            '//' : this._filterConverter.getValue('dirpath')[0];
          var _self = this;
          var query = {};
          // dirpath must end with / to match data in elasticsearch
          if (dirpath.slice(-1) !== '/') {
            dirpath += '/';
          }

          query = {
            size: 20,
            from: this.from,
            query: {
              constant_score: {
                filter: {
                  bool: {
                    must: [
                      {
                        'bool': {
                          'should': [
                            {
                              'term': {
                                'exists_on_disk': true
                              }
                            },
                            {
                              'exists': {
                                'field': 'archive_complete'
                              }
                            }
                          ]
                        }
                      },
                      {
                        term: {
                          'metadata.dirpath': dirpath
                        }
                      }
                    ]
                  }
                }
              }
            }
          };

          query.query.constant_score.filter.bool.must.push(this._filterConverter.asElasticsearchFilters());

          return qwest.post(
            this.endpointList.ESFiles,
            {
              index: "files",
              type: "file",
              query: query
            },
            {
              dataType: 'json',
              cache: true,
              headers: {
                Accept: 'application/json',
                Authorization: 'JWT ' + localStorage.getItem('authToken')
              }
            }, function(xhr) {
              // Push the XMLHttpRequest to be able to abort the request if necessary
              _self.xhrPool.push(xhr);
            }).then(function(xhr, response) {
              _.forEach(response.hits.hits, function(item) {
                item.id_b64 = btoa(encodeURIComponent(item._id));
                try {
                  item.color = docTypeColorMap[item._source.metadata.doc_type];
                } catch (exc) {
                  item.color = '#ff7f0e';
                }
              });

              return response;
            }).catch(this.handleNetworkError);
        },
        attached: function() {
          Polymer.dom.flush();
          this.tookStats = this.tookStats || {
              took: undefined,
              fileResults: undefined,
              directoryResults: undefined
            };

          // Selects its filter converter, if not,
          // the one from kazoup-analytics can be selected erroneously
          // trigerring observer in the wrong place
          this._filterConverter = Polymer.dom(document)
            .querySelector(this.target)
            .querySelector('#filterConverter');
          this._filterConverter.addEventListener('filters-changed', this._filtersChanged.bind(this));
        }
      });
    }());
  </script>
</dom-module>
