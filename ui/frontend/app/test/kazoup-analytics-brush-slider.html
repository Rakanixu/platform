<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>kazoup-analytics</title>

  <script src="/app/bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <script src="/app/bower_components/web-component-tester/browser.js"></script>

  <!-- Tests dependencies -->
  <script src="/app/bower_components/d3/d3.min.js"></script>
  <script src="/app/bower_components/d3-tip/index.js"></script>
  <link rel="import" href="../elements/kazoup-analytics-brush-slider/kazoup-analytics-brush-slider.html">

</head>
<body>

<kazoup-analytics-brush-slider id="fixture"></kazoup-analytics-brush-slider>

<script>
  suite('<kazoup-analytics-brush-slider>', function() {
    var el = document.querySelector('#fixture');
    var data1 = [{"filterType":"extension","term":".png","count":21753,"total":672845473,"size_human":641.68,"size_human_measure":"MB","nestedDimension":{"term":".png","count":21753,"total":672845473},"percent":0.004329343820180522}];
    var data2 = [{"filterType":"extension","term":".png","count":21753,"total":672845473,"size_human":641.68,"size_human_measure":"MB","nestedDimension":{"term":".png","count":21753,"total":672845473},"percent":0.004329343820180522},{"filterType":"extension","term":".js","count":19164,"total":375042501,"size_human":357.67,"size_human_measure":"MB","nestedDimension":{"term":".js","count":19164,"total":375042501},"percent":0.0024131661713794384},{"filterType":"extension","term":".pdf","count":17055,"total":8570568164,"size_human":7.98,"size_human_measure":"GB","nestedDimension":{"term":".pdf","count":17055,"total":8570568164},"percent":0.055146297040255664},{"filterType":"extension","term":".gif","count":15269,"total":26370129,"size_human":25.15,"size_human_measure":"MB","nestedDimension":{"term":".gif","count":15269,"total":26370129},"percent":0.00016967544496433457},{"filterType":"extension","term":".html","count":11440,"total":251628420,"size_human":239.97,"size_human_measure":"MB","nestedDimension":{"term":".html","count":11440,"total":251628420},"percent":0.001619073009812446}];

    suite('chartDataChanged', function() {
      setup(function() {
        sinon.spy(el, 'resetExtentValues');
        sinon.spy(el, 'renderBrushSlider');
        sinon.spy(el, 'setBrushLimits');
        sinon.spy(el, 'setElementVivibility');
        sinon.spy(el, 'brushend');
      });

      teardown(function() {
        el.resetExtentValues.restore();
        el.renderBrushSlider.restore();
        el.setBrushLimits.restore();
        el.setElementVivibility.restore();
        el.brushend.restore();
      });

      suite('when chartData is previously undefined', function() {
        test('should do nothing', function () {
          el.chartDataChanged([], undefined);

          assert(el.resetExtentValues.notCalled);
          assert(el.renderBrushSlider.notCalled);
          assert(el.setBrushLimits.notCalled);
          assert(el.setElementVivibility.notCalled);
          assert(el.brushend.notCalled);
        });
      });

      suite('when chartData is previously defined', function() {
        test('should reset extent values', function() {
          el.chartDataChanged(data2, data1);

          assert(el.resetExtentValues.calledOnce);
          assert(el.brushend.calledOnce);
        });

        test('should render and show element', function() {
          el.viewType = 'unidimensional';
          el.chartData = data2;
          el.maxRange = 3;
          el.chartDataChanged(data2, []);

          assert(el.renderBrushSlider.calledOnce);
          assert(el.setBrushLimits.calledOnce);
          assert(el.setElementVivibility.calledWith(true));
          assert(el.brushend.calledOnce);
        });

        test('should hide the element', function() {
          el.viewType = 'unidimensional';
          el.chartData = data2;
          el.maxRange = 100;
          el.chartDataChanged(data2, []);

          assert(el.setElementVivibility.calledWith(false));
          assert(el.brushend.calledOnce);
        });

      });
    });

    suite('visualisationChanged', function() {
      suite('should set viewType', function() {
        test('unidimensional', function() {
          el.visualisation = 'bubble';

          assert.equal(el.viewType, 'unidimensional');
        });

        test('bidimensional', function() {
          el.visualisation = 'chord';

          assert.equal(el.viewType, 'bidimensional');
        });
      });
    });

    suite('dimensionChanged', function() {
      setup(function() {
        el.dimension = 'dirpath';

        sinon.spy(el, 'resetExtentValues');
      });

      teardown(function() {
        el.resetExtentValues.restore();
      });

      test('should reset extent values', function() {
        el.dimension = 'extension';

        assert(el.resetExtentValues.calledOnce);
      });
    });

    suite('renderBrushSlider', function() {
      setup(function() {
        sinon.spy(el, 'renderBrushSlider');
      });

      teardown(function() {
        el.renderBrushSlider.restore();
      });

      test('should render element', function() {
        el.renderBrushSlider();

        assert(el.renderBrushSlider.calledOnce);
      });
    });

    suite('setElementVivibility', function() {
      test('visible should be false when rendering table view', function() {
        el.visualisation = 'table';
        el.setElementVivibility(true);

        assert.equal(el.visible, false);

        el.visualisation = 'table';
        el.setElementVivibility(false);

        assert.equal(el.visible, false);
      });

      test('visible should be false', function() {
        el.visualisation = 'bubble';
        el.setElementVivibility(false);

        assert.equal(el.visible, false);
      });

      test('visible should be true', function() {
        el.visualisation = 'bubble';
        el.setElementVivibility(true);

        assert.equal(el.visible, true);
      });
    });

    suite('setBrushLimits', function() {
      setup(function() {
        sinon.spy(el.brush, 'extent');
      });

      teardown(function() {
        el.brush.extent.restore();
      });

      test('should call brush extent', function() {
        el.setBrushLimits();

        assert(el.brush.extent.calledOnce);
      });
    });

    suite('setExtentValuesFromQueryParams', function() {
      test('should update extendA & extendB values with those set in URL', function() {
        el.extentA = null;
        el.extentB = null;
        el.setExtentValuesFromQueryParams();

        assert.notEqual(el.extentA, null);
        assert.notEqual(el.extentB, null);
      });
    });

    suite('resetExtentValues', function() {
      test('should reset extent values', function() {
        el.resetExtentValues();

        assert.equal(el.extentA, undefined);
        assert.equal(el.extentB, undefined);
      });
    });

    suite('getDataFromIndex', function() {
      test('should retrieve all chartData between indexes given', function() {
        var dataSubset;

        el.chartData = data2;
        dataSubset = el.getDataFromIndex(1,3);

        assert.deepEqual(dataSubset, [data2[1], data2[2]]);
      });
    });

    suite('getAllData', function() {
      test('should retrieve all chartData', function() {
        var allData;

        el.chartData = data2;
        allData = el.getAllData();

        assert.deepEqual(allData, data2);
      });
    });

    suite('checkCustomRange', function() {
      setup(function() {
        el.customMaxRange = 20;
        el.brush.extent([50, 94]);

        sinon.spy(el, 'setBrushLimits');
      });

      teardown(function() {
        el.setBrushLimits.restore();
      });

      test('should ensure extentA & extentB values represent percentage [0,100]', function() {
        var arrayRange = [5, 49]
        el.lastExtentValues = arrayRange;
        el.checkCustomRange();

        assert(el.setBrushLimits.calledOnce);
        assert.equal(el.extentA, arrayRange[0]);
        assert.equal(el.extentB, arrayRange[1]);

      });
    });

    suite('brushstart', function() {
      setup(function() {
        sinon.spy(el, 'checkCustomRange');
      });

      teardown(function() {
        el.checkCustomRange.restore();
      });

      test('should call checkCustomRange', function() {
        el.brushstart();

        assert(el.checkCustomRange.calledOnce);
      });
    });

    suite('brushmove', function() {
      setup(function() {
        sinon.spy(el, 'checkCustomRange');
      });

      teardown(function() {
        el.checkCustomRange.restore();
      });

      test('should call checkCustomRange', function() {
        el.brushmove();

        assert(el.checkCustomRange.calledOnce);
      });
    });

    suite('brushend', function() {
      setup(function() {
        el.viewType = 'unidimensional';
        el.chartData = data2;

        sinon.spy(el, 'fire');
        sinon.spy(history, 'pushState');
        sinon.spy(el, 'getDataFromIndex');
      });

      teardown(function() {
        el.fire.restore();
        history.pushState.restore();
        el.getDataFromIndex.restore();
      });

      test('should call history.pushState', function() {
        el.brushend();

        assert(window.history.pushState.calledOnce);
      });

      suite('should fire "data-chart" element\'s event', function() {
        test('with partial data', function() {
          var arrayRange = [0, 80];
          el.maxRange = data2.length - 1;
          el.brush.extent(arrayRange);
          el.brushend();

          assert(el.getDataFromIndex.calledOnce);
          assert(el.fire.calledWith('data-chart', {
            data: data2.slice(
              parseInt(arrayRange[0] * data2.length / 100),
              parseInt(arrayRange[1] * data2.length / 100)
            )
          }));
        });

        test('with whole data', function() {
          el.maxRange = data2.length + 1;
          el.brushend();

          assert(el.getDataFromIndex.notCalled);
          assert(el.fire.calledWith('data-chart', {
            data: data2
          }));
        });
      });
    });

    suite('previous', function() {
      setup(function() {
        sinon.spy(el, 'setBrushLimits');
        sinon.spy(el, 'brushend');
      });

      teardown(function() {
        el.setBrushLimits.restore();
        el.brushend.restore();
      });

      test('should set same range [0,X]', function() {
        el.extentA = 0;
        el.extentB = 25;
        el.previous();

        assert(el.setBrushLimits.notCalled);
        assert(el.brushend.notCalled);
        assert.equal(el.extentA, 0);
        assert.equal(el.extentB, 25);
      });

      test('should set previous range (without intersection & contained in [0,100])', function() {
        el.extentA = 10;
        el.extentB = 50;
        el.previous();

        assert(el.setBrushLimits.calledOnce);
        assert(el.brushend.calledOnce);
        assert.equal(el.extentA, 0);
        assert.equal(el.extentB, 10);
      });

      test('should set previous range (without intersection & contained in [0,100])', function() {
        el.extentA = 50;
        el.extentB = 70;
        el.previous();

        assert(el.setBrushLimits.calledOnce);
        assert(el.brushend.calledOnce);
        assert.equal(el.extentA, 30);
        assert.equal(el.extentB, 50);
      });
    });

    suite('next', function() {
      setup(function() {
        sinon.spy(el, 'setBrushLimits');
        sinon.spy(el, 'brushend');
      });

      teardown(function() {
        el.setBrushLimits.restore();
        el.brushend.restore();
      });

      test('should set same range [X,100]', function() {
        el.extentA = 70;
        el.extentB = 100;
        el.next();

        assert(el.setBrushLimits.notCalled);
        assert(el.brushend.notCalled);
      });

      test('should set next range (without intersection & contained in [0,100])', function() {
        el.extentA = 70;
        el.extentB = 90;
        el.next();

        assert(el.setBrushLimits.calledOnce);
        assert(el.brushend.calledOnce);
        assert.equal(el.extentA, 90);
        assert.equal(el.extentB, 100);
      });

      test('should set next range (without intersection & contained in [0,100])', function() {
        el.extentA = 50;
        el.extentB = 70;
        el.next();

        assert(el.setBrushLimits.calledOnce);
        assert(el.brushend.calledOnce);
        assert.equal(el.extentA, 70);
        assert.equal(el.extentB, 90);
      });
    });
  });
</script>
</body>
</html>
