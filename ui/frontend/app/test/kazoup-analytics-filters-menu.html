<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>kazoup-analytics-filters-menu</title>

  <script src="/app/bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <script src="/app/bower_components/web-component-tester/browser.js"></script>

  <!-- Tests dependencies -->
  <script src="/app/bower_components/draggabilly/dist/draggabilly.pkgd.min.js"></script>
  <link rel="import" href="../behaviors/behaviors.html">
  <link rel="import" href="../elements/kazoup-analytics-filters-menu/kazoup-analytics-filters-menu.html">

</head>
<body>

<kazoup-analytics-filters-menu id="fixture"></kazoup-analytics-filters-menu>

<script>
  suite('<kazoup-analytics-filters-menu>', function() {
    var el = document.querySelector('#fixture');

    function setObserversStub() {
      sinon.stub(el, 'dimensionChanged', function() {});
      sinon.stub(el, 'secondDimensionChanged', function() {});
      sinon.stub(el, 'visualisationChanged', function() {});
    }

    function restoreObserversStub() {
      el.dimensionChanged.restore();
      el.secondDimensionChanged.restore();
      el.visualisationChanged.restore();
    }

    suite('dimensionChanged', function() {
      setup(function() {
        el.analytics = {
          buildQuery: function() {}
        };
        el.dimension = 'extension';
        sinon.spy(el.analytics, 'buildQuery');
      });

      teardown(function() {
        el.analytics.buildQuery.restore();
      });

      test('should call <kazoup-analytics>.buildQuery', function() {
        el.dimensionChanged();

        assert(el.analytics.buildQuery.calledOnce);
        assert.equal(el.dimensionSelected, 2);
      });
    });

    suite('secondDimensionChanged', function() {
      setup(function() {
        el.analytics = {
          buildQuery: function() {}
        };
        sinon.spy(el.analytics, 'buildQuery');
      });

      teardown(function() {
        el.analytics.buildQuery.restore();
      });

      test('should call <kazoup-analytics>.buildQuery', function() {
        el.secondDimensionChanged();

        assert(el.analytics.buildQuery.calledOnce);
      });
    });

    suite('visualisationChanged', function() {
      setup(function() {
        el.analytics = {
          buildQuery: function() {}
        };
        el.visualisation = 'treemap';
        sinon.spy(el.analytics, 'buildQuery');
      });

      teardown(function() {
        el.analytics.buildQuery.restore();
      });

      test('should call <kazoup-analytics>.buildQuery', function() {
        el.visualisationChanged();

        assert(el.analytics.buildQuery.calledOnce);
        assert.equal(el.visualisationSelected, 1);
      });
    });

    suite('dragNodes', function() {
      test('should set top positioning to draggabilly nodes', function(done) {
        el.visualisation = 'chord';
        el.dimension = 'location'
        el.secondDimension = 'extension';

        el.dragNodes();

        setTimeout(function() {
          assert.isString(el.$.draggieParentDimension.style.top);
          assert.isString(el.$.draggieChildDimension.style.top);
          assert.isAbove(
            parseInt(el.$.draggieChildDimension.style.top),
            parseInt(el.$.draggieParentDimension.style.top)
          );

          done();
        }, 100);
      });
    });

    suite('setDimension', function() {
      var event = {
        target: {
          dataset: {
            dimension: 'location'
          }
        },
        stopPropagation: function() {}
      };
      var data = {
        dimension: 'location'
      };

      setup(function() {
        el.visualisation = 'chord';

        setObserversStub();
        sinon.spy(event, 'stopPropagation');
        sinon.spy(el, 'set');
      });

      teardown(function() {
        restoreObserversStub();
        event.stopPropagation.restore();
        el.set.restore();
      });

      test('should set dimension from event (unidimensional)', function() {
        el.setDimension(event, undefined, undefined);

        assert(event.stopPropagation.calledOnce);
        assert(el.set.withArgs('dimension', event.target.dataset.dimension));
      });

      test('should set dimension from data param (bidimensional)', function() {
        el.setDimension(undefined, undefined, data);

        assert(event.stopPropagation.notCalled);
        assert(el.set.withArgs('dimension', data.dimension));
      });
    });

    suite('setSecondDimension', function() {
      var data = {
        secondDimension: 'location'
      };

      setup(function() {
        setObserversStub()
        sinon.spy(el, 'set');
      });

      teardown(function() {
        restoreObserversStub();
        el.set.restore();
      });

      test('should set secondDimension', function() {
        el.setSecondDimension(undefined, undefined, data);

        assert(el.set.withArgs('secondDimension', data.secondDimension));
      });
    });

    suite('setVisualisation', function() {
      var event = {
        target: {
          dataset: {}
        }
      };

      setup(function() {
        setObserversStub();
        sinon.spy(el, 'set');
        sinon.stub(el, 'resetDimensionHighlighing', function() {});
      });

      teardown(function() {
        restoreObserversStub();
        el.set.restore();
        el.resetDimensionHighlighing.restore();
      });

      suite('for unidimensional view',  function() {
        test('should set visualisation & default secondDimension', function() {
          event.target.dataset.visualisation = 'treemap';

          el.setVisualisation(event, undefined, undefined);

          assert(el.set.withArgs('visualisation', event.target.dataset.visualisation));
          assert(el.resetDimensionHighlighing.calledOnce);
        });
      });

      suite('for bidimensional view', function() {
        test('should set visualisation & update draggies', function() {
          event.target.dataset.visualisation = 'chord';
          el.secondDimension = 'none';

          el.setVisualisation(event, undefined, undefined);

          assert(el.set.withArgs('visualisation', event.target.dataset.visualisation));
          assert.equal(
            el.$.draggieChildDimension.style.top,
            el.$.draggieParentDimension.style.top
          );
          assert(el.resetDimensionHighlighing.notCalled);
        });
      });
    });

    suite('resetDimensionHighlighing', function() {
      setup(function() {
        sinon.stub(Polymer, 'dom', function(param) {
          return {
            querySelectorAll: function(param) {
              return [{},{},{}];
            },
            removeAttribute: function(param) {}
          }
        });
      });

      teardown(function() {
        Polymer.dom.restore();
      });

      test('should remove active class from dimensions DOM elements', function() {
        el.resetDimensionHighlighing();

        assert(Polymer.dom.calledWith(el.root));
        assert(Polymer.dom.calledWith({}));
      });
    });

    suite('init', function() {
      var event = {
        data: {}
      };

      setup(function() {
        sinon.stub(el, 'resetDimensionHighlighing', function() {});
        sinon.stub(el, 'dragNodes', function() {});
      });

      teardown(function() {
        el.resetDimensionHighlighing.restore();
        el.dragNodes.restore();
      });

      test('should initialize element with default visualisation', function(done) {
        event.data.visualisation = '';
        el.init(event);

        setTimeout(function() {
          assert(el.resetDimensionHighlighing.calledOnce);
          assert(el.dragNodes.calledOnce);
          assert.equal(el.visualisationSelected, 0);

          done();
        }, 850);
      });

      test('should initialize element with passed visualisation', function(done) {
        event.data.visualisation = 'bubble';
        el.init(event);

        setTimeout(function() {
          assert(el.resetDimensionHighlighing.calledOnce);
          assert(el.dragNodes.calledOnce);
          assert.equal(el.visualisationSelected, 0);

          done();
        }, 850);
      });
    });

    suite('_computeDraggies', function() {
      test('should return false for bidimensional views', function() {
        assert.isFalse(el._computeDraggies('chord'));
      });

      test('should return true otherwise', function() {
        assert.isTrue(el._computeDraggies());
      });
    })
  });
</script>
</body>
</html>
