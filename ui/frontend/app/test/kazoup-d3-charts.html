<!doctype html>
<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <title>kazoup-d3-charts</title>

  <script src="/app/bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <script src="/app/bower_components/web-component-tester/browser.js"></script>

  <!-- Tests dependencies -->
  <script src="/app/bower_components/filesize.js/lib/filesize.min.js"></script>
  <link rel="import" href="../behaviors/behaviors.html">
  <link rel="import" href="../elements/kazoup-d3-charts/kazoup-d3-charts.html">


</head>
<body>

<kazoup-d3-charts id="fixture"></kazoup-d3-charts>

<svg id="paper1"><title>svg</title></svg>
<svg id="paper2"><title>svg</title></svg>
<svg id="paper3"><title>svg</title></svg>
<svg id="paper4"><title>svg</title></svg>
<svg id="paper5"><title>svg</title></svg>
<svg id="paper6"><title>svg</title></svg>
<svg id="paper7"><title>svg</title></svg>
<svg id="paper8"><title>svg</title></svg>

<script>
  /*
  * We will use d3 DOM API for selectors.
  * It will be easier to assert the correctness of DOM after a render method is executed.
  *
  * We do not set timeouts to assert generated DOM. This is because we only worry about DOM existance,
  * we assume transitions are correct (depends on browser native functionality)
  * */
  suite('<kazoup-d3-charts>', function() {
    var el = document.querySelector('#fixture');
    var dataUnidimensional = [
      {
        count: 868,
        depth: 1,
        filterType: "unique",
        nestedDimension: {
          count: 868,
          key: "unique",
          term: "T",
          total: 1143034395
        },
        percent: 0.5,
        r: 172.8461044154788,
        size_human: 1.06,
        size_human_measure: "GB",
        term: "unique",
        total: 1143034395,
        value: 1143034395,
        visible: true,
        x: 399.6538955845212,
        y: 213.5
      },
      {
        count: 868,
        depth: 1,
        filterType: "unique",
        nestedDimension: {
          count: 868,
          key: "unique",
          term: "T",
          total: 1143034395
        },
        percent: 0.5,
        r: 172.8461044154788,
        size_human: 1.06,
        size_human_measure: "GB",
        term: "not_unique",
        total: 1143034395,
        value: 1143034395,
        visible: true,
        x: 399.6538955845212,
        y: 213.5
      }
    ];
    var dataBidimensional = {
      data: dataUnidimensional,
      labels: [
        {
          group: 1,
          term: "unique"
        },
        {
          group: 2,
          term: "not_unique"
        }
      ]
    };
    var width = 500;
    var height = 500;

    function setStubPolymerDOM_API() {
      var domEl = {
        querySelector: qSelector, // For chainability
        querySelectorAll: qSelectorAll,
        remove: function() {},
        getBoundingClientRect: function() {
          return {
            width: 0,
            height: 0
          };
        }
      };

      function qSelector() {
        return domEl;
      }

      function qSelectorAll() {
        return [
          domEl
        ];
      }

      sinon.stub(Polymer, 'dom', function(param) {
        return {
          querySelector: qSelector,
          querySelectorAll: qSelectorAll
        };
      });
    }

    function restoreStubPolymerDOM_API() {
      Polymer.dom.restore();
    }

    function setStubBrushSlider() {
      el._brushSlider = {
        getAllData: function() {}
      };

      sinon.stub(el._brushSlider, 'getAllData', function() {
        return dataUnidimensional;
      });
    }

    function restoreStubBrushSlider() {
      el._brushSlider.getAllData.restore();
    }

    suite('chartDataChanged', function() {
      setup(function() {
        sinon.stub(el, 'visualisationChanged', function() {});
        sinon.stub(el, 'prepare', function() {});
      });

      teardown(function() {
        el.visualisationChanged.restore();
        el.prepare.restore();
      });

      test('should call "prepare" method for unidimensional view', function() {
        el.visualisation = 'bubble';

        el.chartDataChanged(dataUnidimensional, []);

        assert.isFalse(el.chartEmptyStateVisible);
        assert(el.prepare.calledOnce);
      });

      test('should call "prepare" method for bidimensional view', function() {
        el.visualisation = 'chord';

        el.chartDataChanged(dataBidimensional, []);

        assert.isFalse(el.chartEmptyStateVisible);
        assert(el.prepare.calledOnce);
      });
    });

    suite('setChartData', function() {
      setup(function() {
        sinon.stub(el, 'prepare', function() {});
      });

      teardown(function() {
        el.prepare.restore();
      });

      test('should set selectedData and call "prepare" method', function() {
        el.setChartData({
          detail: {
            data: dataUnidimensional
          }
        });

        assert.equal(el.selectedData, dataUnidimensional);
        assert(el.prepare.calledOnce);
      });
    });

    suite('visualisationChanged', function() {
      setup(function() {
        setStubPolymerDOM_API()
      });

      teardown(function() {
        restoreStubPolymerDOM_API()
      });

      test('should remove specific charts markup', function() {
        el.visualisationChanged();

        sinon.assert.callCount(Polymer.dom, 4);
      });
    });

    suite('removeFilter', function() {
      setup(function() {
        el._filterConverter = {
          setValue: function(p1, p2) {},
          removeValue: function(p1, p2) {}
        };

        sinon.spy(el._filterConverter, 'setValue');
        sinon.spy(el._filterConverter, 'removeValue');
      });

      teardown(function() {
        el._filterConverter.setValue.restore();
        el._filterConverter.removeValue.restore();
      });

      test('should remove given filter', function() {
        var filter = {
          dimension: 'q',
          label: 'query term'
        };

        el.removeFilter(filter);

        assert(el._filterConverter.setValue.calledWith(filter.dimension, undefined));
        assert(el._filterConverter.removeValue.notCalled);
      });

      test('should remove given filter', function() {
        var filter = {
          dimension: 'doc_type',
          label: 'PDF Files'
        };

        el.removeFilter(filter);

        assert(el._filterConverter.setValue.notCalled);
        assert(el._filterConverter.removeValue.calledWith(filter.dimension, filter.label));
      });
    });

    suite('setBucketFilter', function() {
      var result;
      var d = {
        count: 48,
        depth: 1,
        filterType: "doc_type",
        term: "Executable Files"
      };

      setup(function() {
        el._filterConverter = {
          asObj: function() {}
        };

        sinon.mock(el._filterConverter).expects('asObj').once().returns([d.term]);
      });

      teardown(function() {
        el._filterConverter.asObj.restore();
      });

      test('should return unchanged data object', function() {
        el.dimension = 'extension';
        result = el.setBucketFilter(d);

        assert.deepEqual(result, d);
      });

      test('should return data object with "filtered" attribute', function() {
        el.dimension = 'doc_type';
        result = el.setBucketFilter(d);

        assert.isTrue(result.filtered);
      });
    });

    suite('hexToRgba', function() {
      test('should return rgba color format', function() {
        var result = el.hexToRgba('#cccccc', 0.5);

        assert.isAbove(result.indexOf('rgba'), -1);
      });
    });

    suite('prepare', function() {
      setup(function() {
        setStubPolymerDOM_API();
        setStubBrushSlider();
        sinon.stub(el, 'renderBubbleChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderPieChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderTreemapChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderWordCloudChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderTableChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderChordChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderForceDirectedChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderSankeyChart', function(p1, p2, p3, p4) {});
        sinon.stub(el, 'renderMatrixChart', function(p1, p2, p3, p4) {});
      });

      teardown(function() {
        restoreStubPolymerDOM_API();
        restoreStubBrushSlider()
        el.renderBubbleChart.restore();
        el.renderPieChart.restore();
        el.renderTreemapChart.restore();
        el.renderWordCloudChart.restore();
        el.renderTableChart.restore();
        el.renderChordChart.restore();
        el.renderForceDirectedChart.restore();
        el.renderSankeyChart.restore();
        el.renderMatrixChart.restore();
      });

      test('should call "renderBubbleChart" method', function() {
        el.visualisation = 'bubble';
        el.prepare();

        assert(el.renderBubbleChart.calledOnce);
      });

      test('should call "renderPieChart" method', function() {
        el.visualisation = 'pie';
        el.prepare();

        assert(el.renderPieChart.calledOnce);
      });

      test('should call "renderTreemapChart" method', function() {
        el.visualisation = 'treemap';
        el.prepare();

        assert(el.renderTreemapChart.calledOnce);
      });

      test('should call "renderWordCloudChart" method', function() {
        el.visualisation = 'word_cloud';
        el.prepare();

        assert(el.renderWordCloudChart.calledOnce);
      });

      test('should call "renderTableChart" method', function() {
        el.visualisation = 'table';
        el.prepare();

        assert(el.renderTableChart.calledOnce);
      });

      test('should call "renderChordChart" method', function() {
        el.visualisation = 'chord';
        el.prepare();

        assert(el.renderChordChart.calledOnce);
      });

      test('should call "renderForceDirectedChart" method', function() {
        el.visualisation = 'force_directed';
        el.prepare();

        assert(el.renderForceDirectedChart.calledOnce);
      });

      test('should call "renderSankeyChart" method', function() {
        el.visualisation = 'sankey';
        el.prepare();

        assert(el.renderSankeyChart.calledOnce);
      });

      test('should call "renderMatrixChart" method', function() {
        el.visualisation = 'matrix';
        el.prepare();

        assert(el.renderMatrixChart.calledOnce);
      });
    });

    suite('renderBubbleChart', function() {
      var svg = d3.select(document.querySelector('#paper1'));

      test('should render a bubble chart', function() {
        el.renderBubbleChart(svg, dataUnidimensional, width, height);

        assert.equal(svg.selectAll('g.node')[0].length, dataUnidimensional.length);
        _.forEach(svg.selectAll('g.node')[0], function(g) {
          assert.isArray(d3.select(g).select('circle'));
          assert.isArray(d3.select(g).select('text'));
        });
      });
    });

    suite('renderPieChart', function() {
      var svg = d3.select(document.querySelector('#paper2'));

      test('should render a pie chart', function() {
        el.renderPieChart(svg, dataUnidimensional, width, height);

        // We only assert slices, because labels and lines can be less that the dataset
        assert.equal(svg.select('g.slices').selectAll('path.slice')[0].length, dataUnidimensional.length);
      });
    });

    suite('renderTreemapChart', function() {
      var svg = d3.select(document.querySelector('#paper3'));

      test('should render a treemap chart', function() {
        el.renderTreemapChart(svg, dataUnidimensional, width, height);

        assert.equal(
          d3.select('div.treemap-container').select('g.g-container').selectAll('div.treemap-node')[0].length,
          dataUnidimensional.length + 1
        );
      });
    });

    suite('renderWordCloudChart', function() {
      var svg = d3.select(document.querySelector('#paper4'));

      test('should render a word cloud chart', function() {
        el.renderWordCloudChart(svg, dataUnidimensional, width, height);

        assert.equal(
          svg.select('g.word-cloud-container').selectAll('text')[0].length,
          dataUnidimensional.length
        );
      });
    });

    suite('renderTableChart', function() {
      var svg = d3.select(document.querySelector('#paper4'));

      test('should render a word cloud chart', function() {
        el.renderTableChart(svg, dataUnidimensional, width, height);

        assert.equal(
          d3.select('div.table-view').select('table tbody').selectAll('tr')[0].length,
          dataUnidimensional.length
        );
      });
    });

    suite('renderChordChart', function() {
      var svg = d3.select(document.querySelector('#paper5'));

      test('should render a chord chart', function() {
        el.renderChordChart(svg, dataBidimensional, width, height);

        assert.equal(
          svg.selectAll('g.groups')[0].length,
          dataBidimensional.data.length
        );
      });
    });

    suite('renderForceDirectedChart', function() {
      var svg = d3.select(document.querySelector('#paper6'));

      test('should render a force directed chart', function() {
        el.renderForceDirectedChart(svg, dataBidimensional, width, height);

        assert.equal(
          svg.selectAll('circle.node-force-directed')[0].length,
          dataBidimensional.data.length
        );
      });
    });

    suite('renderSankeyChart', function() {
      var svg = d3.select(document.querySelector('#paper7'));

      test('should render a sankey chart', function() {
        el.renderSankeyChart(svg, dataBidimensional, width, height);

        assert.equal(
          svg.selectAll('g.sankey-node')[0].length,
          dataBidimensional.data.length
        );
      });
    });

    suite('renderMatrixChart', function() {
      var svg = d3.select(document.querySelector('#paper7'));

      test('should render a matrix chart', function() {
        el.renderMatrixChart(svg, dataBidimensional, width, height);

        assert.equal(
          svg.selectAll('g.row')[0].length,
          dataBidimensional.data.length
        );
      });
    });
  });
</script>
</body>
</html>
