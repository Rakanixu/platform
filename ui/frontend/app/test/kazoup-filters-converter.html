<!doctype html>
<html>
<head>
  <meta charset="UTF-8">

  <script src="/app/bower_components/webcomponentsjs/webcomponents-lite.min.js"></script>
  <script src="/app/bower_components/web-component-tester/browser.js"></script>

  <!-- Tests dependencies -->
  <link rel="import" href="/app/bower_components/polymer/polymer.html">
  <link rel="import" href="../elements/kazoup-filters-converter/kazoup-filters-converter.html">

</head>
<body>

<kazoup-filters-converter id="fixture"></kazoup-filters-converter>
<script>
  suite('<kazoup-filters-converter>', function() {
    var el = document.getElementById('fixture');
    var filters = {
      dirpath: ["//some/path/½½&½=½½.txt"],
      filename: ['ståle.txt'],
      extension: ['.pdf', '.docx'],
      archive_status: ['archived'],
      doc_type: ['Image Files']
    };

    suite('filtersChanged', function() {
      setup(function() {
        sinon.spy(el, 'fire');
      });

      teardown(function() {
        el.fire.restore();
      });

      test('should fire "filters-changed" with empty object', function() {
        el.filtersChanged();

        assert(el.fire.calledWith('filters-changed', {}));
      });
    });

    suite('_fireChangedEvent', function() {
      var field = 'doc_type';
      var oldVal = 'Image Files';
      var newVal = 'Video Files';

      setup(function() {
        sinon.spy(el, 'fire');
      });

      teardown(function() {
        el.fire.restore();
      });

      test('should fire "filters-changed" with old and new values', function() {
        el._fireChangedEvent(field, oldVal, newVal);

        assert(el.fire.calledWith('filters-changed', {
          fieldsChanged: [{
            field: field,
            newValue: newVal,
            oldValue: oldVal
          }]
        }));
      });

      test('should not fire "filters-changed"', function() {
        el._fireChangedEvent(field, oldVal, oldVal);

        assert(el.fire.notCalled);
      });
    });

    suite('_setSingleValue', function() {
      suite('with value', function() {
        test('should set filter', function() {
          var field = 'unique';
          var val = 'unknown';

          el._setSingleValue(field, val);

          assert.equal(el._filters[field], val);
        });
      });

      suite('without value', function() {
        test('should set default (accessed) timestamp', function() {
          var field = 'timestampType';

          el._setSingleValue(field);

          assert.equal(el._filters[field], 'accessed');
        });

        test('should delete filter', function() {
          var field = 'unique';

          el._setSingleValue(field);

          assert.equal(el._filters[field], undefined);
        });
      });
    });

    suite('addValue', function() {
      setup(function() {
        sinon.spy(el, '_fireChangedEvent');
        sinon.spy(el, '_setSingleValue');
        sinon.spy(el, 'set');
      });

      teardown(function() {
        el._fireChangedEvent.restore();
        el._setSingleValue.restore();
        el.set.restore();
      });

      test('should  add a filter value', function() {
        var field = 'extension';
        var val = '.js';

        el.addValue(field, val);

        assert(el.set.calledOnce);
        assert(el._setSingleValue.notCalled);
        assert(el._fireChangedEvent.calledOnce);
      });

      test('should  add several filter values', function() {
        var field = 'extension';
        var val1 = '.js';
        var val2 = '.py';

        el.addValue(field, val1);
        el.addValue(field, val2);

        assert(el.set.calledTwice);
        assert(el._setSingleValue.notCalled);
        assert(el._fireChangedEvent.calledTwice);
        assert.isAbove(el._filters[field].indexOf(val1), -1);
        assert.isAbove(el._filters[field].indexOf(val2), -1);
      });

      test('should call "_setSingleValue"', function() {
        var field = 'from';
        var val = '16y/d-now';

        el.addValue(field, val);

        assert(el._setSingleValue.calledOnce);
        assert(el._fireChangedEvent.calledOnce);
      });
    });

    suite('removeValue', function() {
      setup(function() {
        sinon.spy(el, '_fireChangedEvent');
      });

      teardown(function() {
        el._fireChangedEvent.restore();
      });

      test('should remove a value', function() {
        el.filters = filters;

        el.removeValue('extension', '.pdf');

        assert.equal(el._filters.extension.indexOf('.pdf'), -1);
        assert(el._fireChangedEvent.calledOnce);
      });
    });

    suite('setValue', function() {
      setup(function() {
        sinon.spy(el, '_fireChangedEvent');
        sinon.spy(el, '_setSingleValue');
      });

      teardown(function() {
        el._fireChangedEvent.restore();
        el._setSingleValue.restore();
      });

      test('should reset filter field (empty Array)', function() {
        var field = 'location';

        el.setValue(field);

        assert.deepEqual(el._filters[field], []);
        assert(el._fireChangedEvent.calledOnce);
        assert(el._setSingleValue.notCalled);
      });

      test('should set single value', function() {
        var field = 'location';
        var val = '//127.0.0.1/path';

        el.setValue(field, val);

        assert.deepEqual(el._filters[field], [val]);
        assert(el._fireChangedEvent.calledOnce);
        assert(el._setSingleValue.notCalled);
      });

      test('should set single value', function() {
        var field = 'from';
        var val = '1y/d-now';

        el.setValue(field, val);

        assert.deepEqual(el._filters[field], val);
        assert(el._fireChangedEvent.calledOnce);
        assert(el._setSingleValue.calledOnce);
      });
    });

    suite('setValues', function() {
      setup(function() {
        sinon.spy(el, 'fire');
      });

      teardown(function() {
        el.fire.restore();
      });
      suite('when it overwrites custom values (complete = true)', function() {
        test('should set new values and reset previous', function() {
          var values = [
            {field: 'doc_type', val: 'Document Files'}
          ];

          el.setValues(values, true);

          assert.deepEqual(el._filters[values[0].field], [values[0].val]);
          assert.deepEqual(el._filters['dirpath'], []);
          assert.deepEqual(el._filters['extension'], []);
          assert.deepEqual(el._filters['archive_status'], []);
          assert(el.fire.calledOnce);
        });
      });

      suite('when it does not overwrites custom values (complete = false)', function() {
        test('should add new values', function() {
          var values = [
            {field: 'doc_type', val: 'Video Files'}
          ];
          el.filters = filters;

          el.setValues(values, false);

          assert.deepEqual(el._filters[values[0].field], [values[0].val]);
          assert(el.fire.calledOnce);
        });
      });
    });

    suite('getValue', function() {
      setup(function() {
        el.filters = filters;
      });

      suite('for unique value attributes', function() {
        test('should return the value', function() {
          var result = el.getValue('doc_type');

          assert.deepEqual(result, filters.doc_type);
        });

        test('should return undefined', function() {
          var result = el.getValue('from');

          assert.equal(result, undefined);
        });
      });

      suite('for multivalue attributes', function() {
        test('should return an Array with values', function() {
          var result = el.getValue('extension');

          assert.deepEqual(result, filters.extension);
        });

        test('should return a empty Array', function() {
          var result = el.getValue('unique');

          assert.deepEqual(result, []);
        });
      });
    });

    suite('saveValues', function() {
      test('should clone filters into "filtersCopy"', function() {
        el.saveValues();

        assert.deepEqual(el.filtersCopy, el.filters);
      });
    });

    suite('setStoredValues', function() {
      test('should clone "filtersCopy" into filters', function() {
        el.setStoredValues();

        assert.deepEqual(el.filters, el.filtersCopy);
      });
    });

    suite('asObj', function() {
      setup(function() {
        el.filters = filters;
      });

      test('should return filters object', function() {
        var result = el.asObj();

        assert.deepEqual(result, filters);
      });
    });

    suite('asObj', function() {
      setup(function() {
        el.filters = filters;
      });

      test('should return filters object', function() {
        var result = el.asObj();

        assert.deepEqual(result, filters);
      });
    });

    suite('asQuerystring', function() {
      setup(function() {
        el.filters = filters;
      });

      test('should return filters as a query string', function() {
        var result = el.asQuerystring();

        assert.equal(result, encodeURIComponent(JSON.stringify(filters)));
      });
    });

    suite('asElasticsearchFilters', function() {
      setup(function() {
        el.filters = {
          dirpath: ["//some/path/½½&½=½½.txt"],
          filename: ['ståle.txt'],
          extension: ['.pdf', '.docx'],
          archive_status: ['archived'],
          doc_type: ['Image Files']
        };
      });

      test('should return filters following ES syntax', function() {
        var result = el.asElasticsearchFilters();

        assert.deepEqual(result, {
          "bool":{
            "must":[
              {
                "prefix":{
                  "metadata.dirpath":"//some/path/½½&½=½½.txt"
                }
              },
              {
                "term": {
                  "metadata.filename_raw":"ståle.txt"
                }
              },
              {
                "bool":{
                  "should":[
                    {
                      "term": {
                        "metadata.extension":".pdf"
                      }
                    },
                    {
                      "term":{
                        "metadata.extension":".docx"
                      }
                    }
                  ]
                }
              },
              {
                "bool":{
                  "should":[
                    {
                      "exists":{
                        "field":"archive_complete"
                     }
                    }
                  ]
                }
              },
              {
                "term":{
                  "metadata.doc_type":"Image Files"
                }
              }
            ]
          }
        });
      });

      test('should return filters following ES syntax and excluding field', function() {
        var result = el.asElasticsearchFilters('doc_type');

        assert.deepEqual(result, {
          "bool":{
            "must":[
              {
                "prefix":{
                  "metadata.dirpath":"//some/path/½½&½=½½.txt"
                }
              },
              {
                "term": {
                  "metadata.filename_raw":"ståle.txt"
                }
              },
              {
                "bool":{
                  "should":[
                    {
                      "term": {
                        "metadata.extension":".pdf"
                      }
                    },
                    {
                      "term":{
                        "metadata.extension":".docx"
                      }
                    }
                  ]
                }
              },
              {
                "bool":{
                  "should":[
                    {
                      "exists":{
                        "field":"archive_complete"
                      }
                    }
                  ]
                }
              }
            ]
          }
        });
      });
    });

    suite('asHumanText', function() {
      test('should return filters as human text', function() {
        var result = el.asHumanText();

        assert.equal(result, 'located under <span class="accent-color-text">//some/path/½½&½=½½.txt</span>,with category <span class="accent-color-text">Image Files</span>,with extension one of <span class="accent-color-text">[.pdf, .docx]</span>,is <span class="accent-color-text">archived</span>');
      });
    });

    suite('_reset', function() {
      test('should reset filters to empty object', function() {
        var result = el._reset();

        assert.deepEqual(el._filters, {});
      });
    });
  });
</script>
</body>
</html>
